[
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "path",
        "importPath": "os",
        "description": "os",
        "isExtraImport": true,
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "sphinx_rtd_theme",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sphinx_rtd_theme",
        "description": "sphinx_rtd_theme",
        "detail": "sphinx_rtd_theme",
        "documentation": {}
    },
    {
        "label": "robosuite",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "robosuite",
        "description": "robosuite",
        "detail": "robosuite",
        "documentation": {}
    },
    {
        "label": "load_controller_config",
        "importPath": "robosuite",
        "description": "robosuite",
        "isExtraImport": true,
        "detail": "robosuite",
        "documentation": {}
    },
    {
        "label": "ALL_GRIPPERS",
        "importPath": "robosuite",
        "description": "robosuite",
        "isExtraImport": true,
        "detail": "robosuite",
        "documentation": {}
    },
    {
        "label": "make",
        "importPath": "robosuite",
        "description": "robosuite",
        "isExtraImport": true,
        "detail": "robosuite",
        "documentation": {}
    },
    {
        "label": "load_controller_config",
        "importPath": "robosuite",
        "description": "robosuite",
        "isExtraImport": true,
        "detail": "robosuite",
        "documentation": {}
    },
    {
        "label": "load_controller_config",
        "importPath": "robosuite",
        "description": "robosuite",
        "isExtraImport": true,
        "detail": "robosuite",
        "documentation": {}
    },
    {
        "label": "abc",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "abc",
        "description": "abc",
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "Interpolator",
        "importPath": "robosuite.controllers.interpolators.base_interpolator",
        "description": "robosuite.controllers.interpolators.base_interpolator",
        "isExtraImport": true,
        "detail": "robosuite.controllers.interpolators.base_interpolator",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "robosuite.utils.transform_utils",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "robosuite.utils.transform_utils",
        "description": "robosuite.utils.transform_utils",
        "detail": "robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "rotation_matrix",
        "importPath": "robosuite.utils.transform_utils",
        "description": "robosuite.utils.transform_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "rotation_matrix",
        "importPath": "robosuite.utils.transform_utils",
        "description": "robosuite.utils.transform_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "convert_quat",
        "importPath": "robosuite.utils.transform_utils",
        "description": "robosuite.utils.transform_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "convert_quat",
        "importPath": "robosuite.utils.transform_utils",
        "description": "robosuite.utils.transform_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "convert_quat",
        "importPath": "robosuite.utils.transform_utils",
        "description": "robosuite.utils.transform_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "mat2quat",
        "importPath": "robosuite.utils.transform_utils",
        "description": "robosuite.utils.transform_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "convert_quat",
        "importPath": "robosuite.utils.transform_utils",
        "description": "robosuite.utils.transform_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "euler2mat",
        "importPath": "robosuite.utils.transform_utils",
        "description": "robosuite.utils.transform_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "mat2quat",
        "importPath": "robosuite.utils.transform_utils",
        "description": "robosuite.utils.transform_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "quat_multiply",
        "importPath": "robosuite.utils.transform_utils",
        "description": "robosuite.utils.transform_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "mujoco_py",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "mujoco_py",
        "description": "mujoco_py",
        "detail": "mujoco_py",
        "documentation": {}
    },
    {
        "label": "MjSim",
        "importPath": "mujoco_py",
        "description": "mujoco_py",
        "isExtraImport": true,
        "detail": "mujoco_py",
        "documentation": {}
    },
    {
        "label": "MjViewer",
        "importPath": "mujoco_py",
        "description": "mujoco_py",
        "isExtraImport": true,
        "detail": "mujoco_py",
        "documentation": {}
    },
    {
        "label": "MjSim",
        "importPath": "mujoco_py",
        "description": "mujoco_py",
        "isExtraImport": true,
        "detail": "mujoco_py",
        "documentation": {}
    },
    {
        "label": "MjRenderContextOffscreen",
        "importPath": "mujoco_py",
        "description": "mujoco_py",
        "isExtraImport": true,
        "detail": "mujoco_py",
        "documentation": {}
    },
    {
        "label": "load_model_from_xml",
        "importPath": "mujoco_py",
        "description": "mujoco_py",
        "isExtraImport": true,
        "detail": "mujoco_py",
        "documentation": {}
    },
    {
        "label": "MjSim",
        "importPath": "mujoco_py",
        "description": "mujoco_py",
        "isExtraImport": true,
        "detail": "mujoco_py",
        "documentation": {}
    },
    {
        "label": "MjViewer",
        "importPath": "mujoco_py",
        "description": "mujoco_py",
        "isExtraImport": true,
        "detail": "mujoco_py",
        "documentation": {}
    },
    {
        "label": "MjSim",
        "importPath": "mujoco_py",
        "description": "mujoco_py",
        "isExtraImport": true,
        "detail": "mujoco_py",
        "documentation": {}
    },
    {
        "label": "load_model_from_path",
        "importPath": "mujoco_py",
        "description": "mujoco_py",
        "isExtraImport": true,
        "detail": "mujoco_py",
        "documentation": {}
    },
    {
        "label": "MjSim",
        "importPath": "mujoco_py",
        "description": "mujoco_py",
        "isExtraImport": true,
        "detail": "mujoco_py",
        "documentation": {}
    },
    {
        "label": "MjViewer",
        "importPath": "mujoco_py",
        "description": "mujoco_py",
        "isExtraImport": true,
        "detail": "mujoco_py",
        "documentation": {}
    },
    {
        "label": "load_model_from_path",
        "importPath": "mujoco_py",
        "description": "mujoco_py",
        "isExtraImport": true,
        "detail": "mujoco_py",
        "documentation": {}
    },
    {
        "label": "cymj",
        "importPath": "mujoco_py",
        "description": "mujoco_py",
        "isExtraImport": true,
        "detail": "mujoco_py",
        "documentation": {}
    },
    {
        "label": "MjViewer",
        "importPath": "mujoco_py",
        "description": "mujoco_py",
        "isExtraImport": true,
        "detail": "mujoco_py",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "copy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "copy",
        "description": "copy",
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "deepcopy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "deepcopy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "deepcopy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "deepcopy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "copy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "deepcopy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "join",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "JointVelocityController",
        "importPath": "robosuite.controllers.joint_vel",
        "description": "robosuite.controllers.joint_vel",
        "isExtraImport": true,
        "detail": "robosuite.controllers.joint_vel",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "robosuite.utils.control_utils",
        "description": "robosuite.utils.control_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.control_utils",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "robosuite.utils.control_utils",
        "description": "robosuite.utils.control_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.control_utils",
        "documentation": {}
    },
    {
        "label": "RingBuffer",
        "importPath": "robosuite.utils.control_utils",
        "description": "robosuite.utils.control_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.control_utils",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "robosuite.utils.control_utils",
        "description": "robosuite.utils.control_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.control_utils",
        "documentation": {}
    },
    {
        "label": "DeltaBuffer",
        "importPath": "robosuite.utils.control_utils",
        "description": "robosuite.utils.control_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.control_utils",
        "documentation": {}
    },
    {
        "label": "RingBuffer",
        "importPath": "robosuite.utils.control_utils",
        "description": "robosuite.utils.control_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.control_utils",
        "documentation": {}
    },
    {
        "label": "DeltaBuffer",
        "importPath": "robosuite.utils.control_utils",
        "description": "robosuite.utils.control_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.control_utils",
        "documentation": {}
    },
    {
        "label": "DeltaBuffer",
        "importPath": "robosuite.utils.control_utils",
        "description": "robosuite.utils.control_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.control_utils",
        "documentation": {}
    },
    {
        "label": "RingBuffer",
        "importPath": "robosuite.utils.control_utils",
        "description": "robosuite.utils.control_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.control_utils",
        "documentation": {}
    },
    {
        "label": "Controller",
        "importPath": "robosuite.controllers.base_controller",
        "description": "robosuite.controllers.base_controller",
        "isExtraImport": true,
        "detail": "robosuite.controllers.base_controller",
        "documentation": {}
    },
    {
        "label": "Controller",
        "importPath": "robosuite.controllers.base_controller",
        "description": "robosuite.controllers.base_controller",
        "isExtraImport": true,
        "detail": "robosuite.controllers.base_controller",
        "documentation": {}
    },
    {
        "label": "Controller",
        "importPath": "robosuite.controllers.base_controller",
        "description": "robosuite.controllers.base_controller",
        "isExtraImport": true,
        "detail": "robosuite.controllers.base_controller",
        "documentation": {}
    },
    {
        "label": "Controller",
        "importPath": "robosuite.controllers.base_controller",
        "description": "robosuite.controllers.base_controller",
        "isExtraImport": true,
        "detail": "robosuite.controllers.base_controller",
        "documentation": {}
    },
    {
        "label": "math",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "math",
        "description": "math",
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "collections",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "collections",
        "description": "collections",
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "namedtuple",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "AtomicSkill",
        "importPath": "robosuite.controllers.skills",
        "description": "robosuite.controllers.skills",
        "isExtraImport": true,
        "detail": "robosuite.controllers.skills",
        "documentation": {}
    },
    {
        "label": "ReachSkill",
        "importPath": "robosuite.controllers.skills",
        "description": "robosuite.controllers.skills",
        "isExtraImport": true,
        "detail": "robosuite.controllers.skills",
        "documentation": {}
    },
    {
        "label": "ReachOSCSkill",
        "importPath": "robosuite.controllers.skills",
        "description": "robosuite.controllers.skills",
        "isExtraImport": true,
        "detail": "robosuite.controllers.skills",
        "documentation": {}
    },
    {
        "label": "GraspSkill",
        "importPath": "robosuite.controllers.skills",
        "description": "robosuite.controllers.skills",
        "isExtraImport": true,
        "detail": "robosuite.controllers.skills",
        "documentation": {}
    },
    {
        "label": "PushSkill",
        "importPath": "robosuite.controllers.skills",
        "description": "robosuite.controllers.skills",
        "isExtraImport": true,
        "detail": "robosuite.controllers.skills",
        "documentation": {}
    },
    {
        "label": "GripperSkill",
        "importPath": "robosuite.controllers.skills",
        "description": "robosuite.controllers.skills",
        "isExtraImport": true,
        "detail": "robosuite.controllers.skills",
        "documentation": {}
    },
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "glob",
        "importPath": "glob",
        "description": "glob",
        "isExtraImport": true,
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "glob",
        "importPath": "glob",
        "description": "glob",
        "isExtraImport": true,
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "DataCollectionWrapper",
        "importPath": "robosuite.wrappers",
        "description": "robosuite.wrappers",
        "isExtraImport": true,
        "detail": "robosuite.wrappers",
        "documentation": {}
    },
    {
        "label": "VisualizationWrapper",
        "importPath": "robosuite.wrappers",
        "description": "robosuite.wrappers",
        "isExtraImport": true,
        "detail": "robosuite.wrappers",
        "documentation": {}
    },
    {
        "label": "DomainRandomizationWrapper",
        "importPath": "robosuite.wrappers",
        "description": "robosuite.wrappers",
        "isExtraImport": true,
        "detail": "robosuite.wrappers",
        "documentation": {}
    },
    {
        "label": "GymWrapper",
        "importPath": "robosuite.wrappers",
        "description": "robosuite.wrappers",
        "isExtraImport": true,
        "detail": "robosuite.wrappers",
        "documentation": {}
    },
    {
        "label": "DataCollectionWrapper",
        "importPath": "robosuite.wrappers",
        "description": "robosuite.wrappers",
        "isExtraImport": true,
        "detail": "robosuite.wrappers",
        "documentation": {}
    },
    {
        "label": "VisualizationWrapper",
        "importPath": "robosuite.wrappers",
        "description": "robosuite.wrappers",
        "isExtraImport": true,
        "detail": "robosuite.wrappers",
        "documentation": {}
    },
    {
        "label": "Wrapper",
        "importPath": "robosuite.wrappers",
        "description": "robosuite.wrappers",
        "isExtraImport": true,
        "detail": "robosuite.wrappers",
        "documentation": {}
    },
    {
        "label": "Wrapper",
        "importPath": "robosuite.wrappers",
        "description": "robosuite.wrappers",
        "isExtraImport": true,
        "detail": "robosuite.wrappers",
        "documentation": {}
    },
    {
        "label": "Wrapper",
        "importPath": "robosuite.wrappers",
        "description": "robosuite.wrappers",
        "isExtraImport": true,
        "detail": "robosuite.wrappers",
        "documentation": {}
    },
    {
        "label": "Wrapper",
        "importPath": "robosuite.wrappers",
        "description": "robosuite.wrappers",
        "isExtraImport": true,
        "detail": "robosuite.wrappers",
        "documentation": {}
    },
    {
        "label": "Wrapper",
        "importPath": "robosuite.wrappers",
        "description": "robosuite.wrappers",
        "isExtraImport": true,
        "detail": "robosuite.wrappers",
        "documentation": {}
    },
    {
        "label": "load_controller_config",
        "importPath": "robosuite.controllers",
        "description": "robosuite.controllers",
        "isExtraImport": true,
        "detail": "robosuite.controllers",
        "documentation": {}
    },
    {
        "label": "load_controller_config",
        "importPath": "robosuite.controllers",
        "description": "robosuite.controllers",
        "isExtraImport": true,
        "detail": "robosuite.controllers",
        "documentation": {}
    },
    {
        "label": "load_controller_config",
        "importPath": "robosuite.controllers",
        "description": "robosuite.controllers",
        "isExtraImport": true,
        "detail": "robosuite.controllers",
        "documentation": {}
    },
    {
        "label": "reset_controllers",
        "importPath": "robosuite.controllers",
        "description": "robosuite.controllers",
        "isExtraImport": true,
        "detail": "robosuite.controllers",
        "documentation": {}
    },
    {
        "label": "controller_factory",
        "importPath": "robosuite.controllers",
        "description": "robosuite.controllers",
        "isExtraImport": true,
        "detail": "robosuite.controllers",
        "documentation": {}
    },
    {
        "label": "load_controller_config",
        "importPath": "robosuite.controllers",
        "description": "robosuite.controllers",
        "isExtraImport": true,
        "detail": "robosuite.controllers",
        "documentation": {}
    },
    {
        "label": "controller_factory",
        "importPath": "robosuite.controllers",
        "description": "robosuite.controllers",
        "isExtraImport": true,
        "detail": "robosuite.controllers",
        "documentation": {}
    },
    {
        "label": "load_controller_config",
        "importPath": "robosuite.controllers",
        "description": "robosuite.controllers",
        "isExtraImport": true,
        "detail": "robosuite.controllers",
        "documentation": {}
    },
    {
        "label": "load_controller_config",
        "importPath": "robosuite.controllers",
        "description": "robosuite.controllers",
        "isExtraImport": true,
        "detail": "robosuite.controllers",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "robosuite.utils.input_utils",
        "description": "robosuite.utils.input_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.input_utils",
        "documentation": {}
    },
    {
        "label": "input2action",
        "importPath": "robosuite.utils.input_utils",
        "description": "robosuite.utils.input_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.input_utils",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "robosuite.utils.input_utils",
        "description": "robosuite.utils.input_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.input_utils",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "robosuite.utils.input_utils",
        "description": "robosuite.utils.input_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.input_utils",
        "documentation": {}
    },
    {
        "label": "input2action",
        "importPath": "robosuite.utils.input_utils",
        "description": "robosuite.utils.input_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.input_utils",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "robosuite.utils.input_utils",
        "description": "robosuite.utils.input_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.input_utils",
        "documentation": {}
    },
    {
        "label": "Bimanual",
        "importPath": "robosuite.robots",
        "description": "robosuite.robots",
        "isExtraImport": true,
        "detail": "robosuite.robots",
        "documentation": {}
    },
    {
        "label": "Manipulator",
        "importPath": "robosuite.robots",
        "description": "robosuite.robots",
        "isExtraImport": true,
        "detail": "robosuite.robots",
        "documentation": {}
    },
    {
        "label": "ROBOT_CLASS_MAPPING",
        "importPath": "robosuite.robots",
        "description": "robosuite.robots",
        "isExtraImport": true,
        "detail": "robosuite.robots",
        "documentation": {}
    },
    {
        "label": "SingleArm",
        "importPath": "robosuite.robots",
        "description": "robosuite.robots",
        "isExtraImport": true,
        "detail": "robosuite.robots",
        "documentation": {}
    },
    {
        "label": "ROBOT_CLASS_MAPPING",
        "importPath": "robosuite.robots",
        "description": "robosuite.robots",
        "isExtraImport": true,
        "detail": "robosuite.robots",
        "documentation": {}
    },
    {
        "label": "SingleArm",
        "importPath": "robosuite.robots",
        "description": "robosuite.robots",
        "isExtraImport": true,
        "detail": "robosuite.robots",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "robosuite.robots",
        "description": "robosuite.robots",
        "isExtraImport": true,
        "detail": "robosuite.robots",
        "documentation": {}
    },
    {
        "label": "BIMANUAL_ROBOTS",
        "importPath": "robosuite.robots",
        "description": "robosuite.robots",
        "isExtraImport": true,
        "detail": "robosuite.robots",
        "documentation": {}
    },
    {
        "label": "robosuite.utils.macros",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "robosuite.utils.macros",
        "description": "robosuite.utils.macros",
        "detail": "robosuite.utils.macros",
        "documentation": {}
    },
    {
        "label": "xml.etree.ElementTree",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "xml.etree.ElementTree",
        "description": "xml.etree.ElementTree",
        "detail": "xml.etree.ElementTree",
        "documentation": {}
    },
    {
        "label": "MujocoWorldBase",
        "importPath": "robosuite.models",
        "description": "robosuite.models",
        "isExtraImport": true,
        "detail": "robosuite.models",
        "documentation": {}
    },
    {
        "label": "TableArena",
        "importPath": "robosuite.models.arenas.table_arena",
        "description": "robosuite.models.arenas.table_arena",
        "isExtraImport": true,
        "detail": "robosuite.models.arenas.table_arena",
        "documentation": {}
    },
    {
        "label": "TableArena",
        "importPath": "robosuite.models.arenas.table_arena",
        "description": "robosuite.models.arenas.table_arena",
        "isExtraImport": true,
        "detail": "robosuite.models.arenas.table_arena",
        "documentation": {}
    },
    {
        "label": "RethinkGripper",
        "importPath": "robosuite.models.grippers",
        "description": "robosuite.models.grippers",
        "isExtraImport": true,
        "detail": "robosuite.models.grippers",
        "documentation": {}
    },
    {
        "label": "PandaGripper",
        "importPath": "robosuite.models.grippers",
        "description": "robosuite.models.grippers",
        "isExtraImport": true,
        "detail": "robosuite.models.grippers",
        "documentation": {}
    },
    {
        "label": "GripperModel",
        "importPath": "robosuite.models.grippers",
        "description": "robosuite.models.grippers",
        "isExtraImport": true,
        "detail": "robosuite.models.grippers",
        "documentation": {}
    },
    {
        "label": "gripper_factory",
        "importPath": "robosuite.models.grippers",
        "description": "robosuite.models.grippers",
        "isExtraImport": true,
        "detail": "robosuite.models.grippers",
        "documentation": {}
    },
    {
        "label": "gripper_factory",
        "importPath": "robosuite.models.grippers",
        "description": "robosuite.models.grippers",
        "isExtraImport": true,
        "detail": "robosuite.models.grippers",
        "documentation": {}
    },
    {
        "label": "GRIPPER_MAPPING",
        "importPath": "robosuite.models.grippers",
        "description": "robosuite.models.grippers",
        "isExtraImport": true,
        "detail": "robosuite.models.grippers",
        "documentation": {}
    },
    {
        "label": "GripperTester",
        "importPath": "robosuite.models.grippers",
        "description": "robosuite.models.grippers",
        "isExtraImport": true,
        "detail": "robosuite.models.grippers",
        "documentation": {}
    },
    {
        "label": "JacoThreeFingerGripper",
        "importPath": "robosuite.models.grippers",
        "description": "robosuite.models.grippers",
        "isExtraImport": true,
        "detail": "robosuite.models.grippers",
        "documentation": {}
    },
    {
        "label": "PandaGripper",
        "importPath": "robosuite.models.grippers",
        "description": "robosuite.models.grippers",
        "isExtraImport": true,
        "detail": "robosuite.models.grippers",
        "documentation": {}
    },
    {
        "label": "GripperTester",
        "importPath": "robosuite.models.grippers",
        "description": "robosuite.models.grippers",
        "isExtraImport": true,
        "detail": "robosuite.models.grippers",
        "documentation": {}
    },
    {
        "label": "RethinkGripper",
        "importPath": "robosuite.models.grippers",
        "description": "robosuite.models.grippers",
        "isExtraImport": true,
        "detail": "robosuite.models.grippers",
        "documentation": {}
    },
    {
        "label": "GripperTester",
        "importPath": "robosuite.models.grippers",
        "description": "robosuite.models.grippers",
        "isExtraImport": true,
        "detail": "robosuite.models.grippers",
        "documentation": {}
    },
    {
        "label": "GripperTester",
        "importPath": "robosuite.models.grippers",
        "description": "robosuite.models.grippers",
        "isExtraImport": true,
        "detail": "robosuite.models.grippers",
        "documentation": {}
    },
    {
        "label": "Robotiq140Gripper",
        "importPath": "robosuite.models.grippers",
        "description": "robosuite.models.grippers",
        "isExtraImport": true,
        "detail": "robosuite.models.grippers",
        "documentation": {}
    },
    {
        "label": "GripperTester",
        "importPath": "robosuite.models.grippers",
        "description": "robosuite.models.grippers",
        "isExtraImport": true,
        "detail": "robosuite.models.grippers",
        "documentation": {}
    },
    {
        "label": "Robotiq85Gripper",
        "importPath": "robosuite.models.grippers",
        "description": "robosuite.models.grippers",
        "isExtraImport": true,
        "detail": "robosuite.models.grippers",
        "documentation": {}
    },
    {
        "label": "GripperTester",
        "importPath": "robosuite.models.grippers",
        "description": "robosuite.models.grippers",
        "isExtraImport": true,
        "detail": "robosuite.models.grippers",
        "documentation": {}
    },
    {
        "label": "RobotiqThreeFingerGripper",
        "importPath": "robosuite.models.grippers",
        "description": "robosuite.models.grippers",
        "isExtraImport": true,
        "detail": "robosuite.models.grippers",
        "documentation": {}
    },
    {
        "label": "BoxObject",
        "importPath": "robosuite.models.objects",
        "description": "robosuite.models.objects",
        "isExtraImport": true,
        "detail": "robosuite.models.objects",
        "documentation": {}
    },
    {
        "label": "BoxObject",
        "importPath": "robosuite.models.objects",
        "description": "robosuite.models.objects",
        "isExtraImport": true,
        "detail": "robosuite.models.objects",
        "documentation": {}
    },
    {
        "label": "DoorObject",
        "importPath": "robosuite.models.objects",
        "description": "robosuite.models.objects",
        "isExtraImport": true,
        "detail": "robosuite.models.objects",
        "documentation": {}
    },
    {
        "label": "BoxObject",
        "importPath": "robosuite.models.objects",
        "description": "robosuite.models.objects",
        "isExtraImport": true,
        "detail": "robosuite.models.objects",
        "documentation": {}
    },
    {
        "label": "SquareNutObject",
        "importPath": "robosuite.models.objects",
        "description": "robosuite.models.objects",
        "isExtraImport": true,
        "detail": "robosuite.models.objects",
        "documentation": {}
    },
    {
        "label": "RoundNutObject",
        "importPath": "robosuite.models.objects",
        "description": "robosuite.models.objects",
        "isExtraImport": true,
        "detail": "robosuite.models.objects",
        "documentation": {}
    },
    {
        "label": "BoxObject",
        "importPath": "robosuite.models.objects",
        "description": "robosuite.models.objects",
        "isExtraImport": true,
        "detail": "robosuite.models.objects",
        "documentation": {}
    },
    {
        "label": "MilkObject",
        "importPath": "robosuite.models.objects",
        "description": "robosuite.models.objects",
        "isExtraImport": true,
        "detail": "robosuite.models.objects",
        "documentation": {}
    },
    {
        "label": "BreadObject",
        "importPath": "robosuite.models.objects",
        "description": "robosuite.models.objects",
        "isExtraImport": true,
        "detail": "robosuite.models.objects",
        "documentation": {}
    },
    {
        "label": "CerealObject",
        "importPath": "robosuite.models.objects",
        "description": "robosuite.models.objects",
        "isExtraImport": true,
        "detail": "robosuite.models.objects",
        "documentation": {}
    },
    {
        "label": "CanObject",
        "importPath": "robosuite.models.objects",
        "description": "robosuite.models.objects",
        "isExtraImport": true,
        "detail": "robosuite.models.objects",
        "documentation": {}
    },
    {
        "label": "MilkVisualObject",
        "importPath": "robosuite.models.objects",
        "description": "robosuite.models.objects",
        "isExtraImport": true,
        "detail": "robosuite.models.objects",
        "documentation": {}
    },
    {
        "label": "BreadVisualObject",
        "importPath": "robosuite.models.objects",
        "description": "robosuite.models.objects",
        "isExtraImport": true,
        "detail": "robosuite.models.objects",
        "documentation": {}
    },
    {
        "label": "CerealVisualObject",
        "importPath": "robosuite.models.objects",
        "description": "robosuite.models.objects",
        "isExtraImport": true,
        "detail": "robosuite.models.objects",
        "documentation": {}
    },
    {
        "label": "CanVisualObject",
        "importPath": "robosuite.models.objects",
        "description": "robosuite.models.objects",
        "isExtraImport": true,
        "detail": "robosuite.models.objects",
        "documentation": {}
    },
    {
        "label": "BoxObject",
        "importPath": "robosuite.models.objects",
        "description": "robosuite.models.objects",
        "isExtraImport": true,
        "detail": "robosuite.models.objects",
        "documentation": {}
    },
    {
        "label": "CylinderObject",
        "importPath": "robosuite.models.objects",
        "description": "robosuite.models.objects",
        "isExtraImport": true,
        "detail": "robosuite.models.objects",
        "documentation": {}
    },
    {
        "label": "BoxObject",
        "importPath": "robosuite.models.objects",
        "description": "robosuite.models.objects",
        "isExtraImport": true,
        "detail": "robosuite.models.objects",
        "documentation": {}
    },
    {
        "label": "CompositeObject",
        "importPath": "robosuite.models.objects",
        "description": "robosuite.models.objects",
        "isExtraImport": true,
        "detail": "robosuite.models.objects",
        "documentation": {}
    },
    {
        "label": "CompositeObject",
        "importPath": "robosuite.models.objects",
        "description": "robosuite.models.objects",
        "isExtraImport": true,
        "detail": "robosuite.models.objects",
        "documentation": {}
    },
    {
        "label": "CompositeBodyObject",
        "importPath": "robosuite.models.objects",
        "description": "robosuite.models.objects",
        "isExtraImport": true,
        "detail": "robosuite.models.objects",
        "documentation": {}
    },
    {
        "label": "BoxObject",
        "importPath": "robosuite.models.objects",
        "description": "robosuite.models.objects",
        "isExtraImport": true,
        "detail": "robosuite.models.objects",
        "documentation": {}
    },
    {
        "label": "CylinderObject",
        "importPath": "robosuite.models.objects",
        "description": "robosuite.models.objects",
        "isExtraImport": true,
        "detail": "robosuite.models.objects",
        "documentation": {}
    },
    {
        "label": "PrimitiveObject",
        "importPath": "robosuite.models.objects",
        "description": "robosuite.models.objects",
        "isExtraImport": true,
        "detail": "robosuite.models.objects",
        "documentation": {}
    },
    {
        "label": "PrimitiveObject",
        "importPath": "robosuite.models.objects",
        "description": "robosuite.models.objects",
        "isExtraImport": true,
        "detail": "robosuite.models.objects",
        "documentation": {}
    },
    {
        "label": "PrimitiveObject",
        "importPath": "robosuite.models.objects",
        "description": "robosuite.models.objects",
        "isExtraImport": true,
        "detail": "robosuite.models.objects",
        "documentation": {}
    },
    {
        "label": "PrimitiveObject",
        "importPath": "robosuite.models.objects",
        "description": "robosuite.models.objects",
        "isExtraImport": true,
        "detail": "robosuite.models.objects",
        "documentation": {}
    },
    {
        "label": "MujocoGeneratedObject",
        "importPath": "robosuite.models.objects",
        "description": "robosuite.models.objects",
        "isExtraImport": true,
        "detail": "robosuite.models.objects",
        "documentation": {}
    },
    {
        "label": "MujocoObject",
        "importPath": "robosuite.models.objects",
        "description": "robosuite.models.objects",
        "isExtraImport": true,
        "detail": "robosuite.models.objects",
        "documentation": {}
    },
    {
        "label": "MujocoXMLObject",
        "importPath": "robosuite.models.objects",
        "description": "robosuite.models.objects",
        "isExtraImport": true,
        "detail": "robosuite.models.objects",
        "documentation": {}
    },
    {
        "label": "MujocoObject",
        "importPath": "robosuite.models.objects",
        "description": "robosuite.models.objects",
        "isExtraImport": true,
        "detail": "robosuite.models.objects",
        "documentation": {}
    },
    {
        "label": "MujocoObject",
        "importPath": "robosuite.models.objects",
        "description": "robosuite.models.objects",
        "isExtraImport": true,
        "detail": "robosuite.models.objects",
        "documentation": {}
    },
    {
        "label": "new_joint",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "new_actuator",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "CustomMaterial",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "CustomMaterial",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "CustomMaterial",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "CustomMaterial",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "IMAGE_CONVENTION_MAPPING",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "array_to_string",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "string_to_array",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "\\",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "xml_path_completion",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "array_to_string",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "xml_path_completion",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "array_to_string",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "string_to_array",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "xml_path_completion",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "xml_path_completion",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "array_to_string",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "string_to_array",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "CustomMaterial",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "find_elements",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "GRIPPER_COLLISION_COLOR",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "new_actuator",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "new_joint",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "array_to_string",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "xml_path_completion",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "xml_path_completion",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "xml_path_completion",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "xml_path_completion",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "xml_path_completion",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "xml_path_completion",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "xml_path_completion",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "xml_path_completion",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "MOUNT_COLLISION_COLOR",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "xml_path_completion",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "xml_path_completion",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "xml_path_completion",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "add_to_dict",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "RED",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "GREEN",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "BLUE",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "CYAN",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "CustomMaterial",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "array_to_string",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "add_to_dict",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "RED",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "GREEN",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "BLUE",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "CustomMaterial",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "array_to_string",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "RED",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "BLUE",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "CustomMaterial",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "get_size",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "get_size",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "get_size",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "get_size",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "new_body",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "new_geom",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "new_site",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "new_joint",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "new_inertial",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "\\",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "string_to_array",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "array_to_string",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "CustomMaterial",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "OBJECT_COLLISION_COLOR",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "\\",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "xml_path_completion",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "array_to_string",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "find_elements",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "xml_path_completion",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "xml_path_completion",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "xml_path_completion",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "xml_path_completion",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "find_elements",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "string_to_array",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "xml_path_completion",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "xml_path_completion",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "xml_path_completion",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "array_to_string",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "ROBOT_COLLISION_COLOR",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "string_to_array",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "find_elements",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "sort_elements",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "\\",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "xml_path_completion",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "postprocess_model_xml",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "save_sim_model",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "postprocess_model_xml",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "new_site",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "new_geom",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "new_body",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "pygame",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pygame",
        "description": "pygame",
        "detail": "pygame",
        "documentation": {}
    },
    {
        "label": "imageio",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "imageio",
        "description": "imageio",
        "detail": "imageio",
        "documentation": {}
    },
    {
        "label": "glfw",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "glfw",
        "description": "glfw",
        "detail": "glfw",
        "documentation": {}
    },
    {
        "label": "Device",
        "importPath": "robosuite.devices",
        "description": "robosuite.devices",
        "isExtraImport": true,
        "detail": "robosuite.devices",
        "documentation": {}
    },
    {
        "label": "Device",
        "importPath": "robosuite.devices",
        "description": "robosuite.devices",
        "isExtraImport": true,
        "detail": "robosuite.devices",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "threading",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "threading",
        "description": "threading",
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "SingleArmEnv",
        "importPath": "robosuite.environments.manipulation.single_arm_env",
        "description": "robosuite.environments.manipulation.single_arm_env",
        "isExtraImport": true,
        "detail": "robosuite.environments.manipulation.single_arm_env",
        "documentation": {}
    },
    {
        "label": "SingleArmEnv",
        "importPath": "robosuite.environments.manipulation.single_arm_env",
        "description": "robosuite.environments.manipulation.single_arm_env",
        "isExtraImport": true,
        "detail": "robosuite.environments.manipulation.single_arm_env",
        "documentation": {}
    },
    {
        "label": "SingleArmEnv",
        "importPath": "robosuite.environments.manipulation.single_arm_env",
        "description": "robosuite.environments.manipulation.single_arm_env",
        "isExtraImport": true,
        "detail": "robosuite.environments.manipulation.single_arm_env",
        "documentation": {}
    },
    {
        "label": "SingleArmEnv",
        "importPath": "robosuite.environments.manipulation.single_arm_env",
        "description": "robosuite.environments.manipulation.single_arm_env",
        "isExtraImport": true,
        "detail": "robosuite.environments.manipulation.single_arm_env",
        "documentation": {}
    },
    {
        "label": "SingleArmEnv",
        "importPath": "robosuite.environments.manipulation.single_arm_env",
        "description": "robosuite.environments.manipulation.single_arm_env",
        "isExtraImport": true,
        "detail": "robosuite.environments.manipulation.single_arm_env",
        "documentation": {}
    },
    {
        "label": "SingleArmEnv",
        "importPath": "robosuite.environments.manipulation.single_arm_env",
        "description": "robosuite.environments.manipulation.single_arm_env",
        "isExtraImport": true,
        "detail": "robosuite.environments.manipulation.single_arm_env",
        "documentation": {}
    },
    {
        "label": "SingleArmEnv",
        "importPath": "robosuite.environments.manipulation.single_arm_env",
        "description": "robosuite.environments.manipulation.single_arm_env",
        "isExtraImport": true,
        "detail": "robosuite.environments.manipulation.single_arm_env",
        "documentation": {}
    },
    {
        "label": "SingleArmEnv",
        "importPath": "robosuite.environments.manipulation.single_arm_env",
        "description": "robosuite.environments.manipulation.single_arm_env",
        "isExtraImport": true,
        "detail": "robosuite.environments.manipulation.single_arm_env",
        "documentation": {}
    },
    {
        "label": "TableArena",
        "importPath": "robosuite.models.arenas",
        "description": "robosuite.models.arenas",
        "isExtraImport": true,
        "detail": "robosuite.models.arenas",
        "documentation": {}
    },
    {
        "label": "TableArena",
        "importPath": "robosuite.models.arenas",
        "description": "robosuite.models.arenas",
        "isExtraImport": true,
        "detail": "robosuite.models.arenas",
        "documentation": {}
    },
    {
        "label": "TableArena",
        "importPath": "robosuite.models.arenas",
        "description": "robosuite.models.arenas",
        "isExtraImport": true,
        "detail": "robosuite.models.arenas",
        "documentation": {}
    },
    {
        "label": "PegsArena",
        "importPath": "robosuite.models.arenas",
        "description": "robosuite.models.arenas",
        "isExtraImport": true,
        "detail": "robosuite.models.arenas",
        "documentation": {}
    },
    {
        "label": "BlockArena",
        "importPath": "robosuite.models.arenas",
        "description": "robosuite.models.arenas",
        "isExtraImport": true,
        "detail": "robosuite.models.arenas",
        "documentation": {}
    },
    {
        "label": "BinsArena",
        "importPath": "robosuite.models.arenas",
        "description": "robosuite.models.arenas",
        "isExtraImport": true,
        "detail": "robosuite.models.arenas",
        "documentation": {}
    },
    {
        "label": "TableArena",
        "importPath": "robosuite.models.arenas",
        "description": "robosuite.models.arenas",
        "isExtraImport": true,
        "detail": "robosuite.models.arenas",
        "documentation": {}
    },
    {
        "label": "WipeArena",
        "importPath": "robosuite.models.arenas",
        "description": "robosuite.models.arenas",
        "isExtraImport": true,
        "detail": "robosuite.models.arenas",
        "documentation": {}
    },
    {
        "label": "Arena",
        "importPath": "robosuite.models.arenas",
        "description": "robosuite.models.arenas",
        "isExtraImport": true,
        "detail": "robosuite.models.arenas",
        "documentation": {}
    },
    {
        "label": "Arena",
        "importPath": "robosuite.models.arenas",
        "description": "robosuite.models.arenas",
        "isExtraImport": true,
        "detail": "robosuite.models.arenas",
        "documentation": {}
    },
    {
        "label": "Arena",
        "importPath": "robosuite.models.arenas",
        "description": "robosuite.models.arenas",
        "isExtraImport": true,
        "detail": "robosuite.models.arenas",
        "documentation": {}
    },
    {
        "label": "TableArena",
        "importPath": "robosuite.models.arenas",
        "description": "robosuite.models.arenas",
        "isExtraImport": true,
        "detail": "robosuite.models.arenas",
        "documentation": {}
    },
    {
        "label": "Arena",
        "importPath": "robosuite.models.arenas",
        "description": "robosuite.models.arenas",
        "isExtraImport": true,
        "detail": "robosuite.models.arenas",
        "documentation": {}
    },
    {
        "label": "TableArena",
        "importPath": "robosuite.models.arenas",
        "description": "robosuite.models.arenas",
        "isExtraImport": true,
        "detail": "robosuite.models.arenas",
        "documentation": {}
    },
    {
        "label": "ManipulationTask",
        "importPath": "robosuite.models.tasks",
        "description": "robosuite.models.tasks",
        "isExtraImport": true,
        "detail": "robosuite.models.tasks",
        "documentation": {}
    },
    {
        "label": "ManipulationTask",
        "importPath": "robosuite.models.tasks",
        "description": "robosuite.models.tasks",
        "isExtraImport": true,
        "detail": "robosuite.models.tasks",
        "documentation": {}
    },
    {
        "label": "ManipulationTask",
        "importPath": "robosuite.models.tasks",
        "description": "robosuite.models.tasks",
        "isExtraImport": true,
        "detail": "robosuite.models.tasks",
        "documentation": {}
    },
    {
        "label": "ManipulationTask",
        "importPath": "robosuite.models.tasks",
        "description": "robosuite.models.tasks",
        "isExtraImport": true,
        "detail": "robosuite.models.tasks",
        "documentation": {}
    },
    {
        "label": "ManipulationTask",
        "importPath": "robosuite.models.tasks",
        "description": "robosuite.models.tasks",
        "isExtraImport": true,
        "detail": "robosuite.models.tasks",
        "documentation": {}
    },
    {
        "label": "ManipulationTask",
        "importPath": "robosuite.models.tasks",
        "description": "robosuite.models.tasks",
        "isExtraImport": true,
        "detail": "robosuite.models.tasks",
        "documentation": {}
    },
    {
        "label": "ManipulationTask",
        "importPath": "robosuite.models.tasks",
        "description": "robosuite.models.tasks",
        "isExtraImport": true,
        "detail": "robosuite.models.tasks",
        "documentation": {}
    },
    {
        "label": "ManipulationTask",
        "importPath": "robosuite.models.tasks",
        "description": "robosuite.models.tasks",
        "isExtraImport": true,
        "detail": "robosuite.models.tasks",
        "documentation": {}
    },
    {
        "label": "UniformRandomSampler",
        "importPath": "robosuite.utils.placement_samplers",
        "description": "robosuite.utils.placement_samplers",
        "isExtraImport": true,
        "detail": "robosuite.utils.placement_samplers",
        "documentation": {}
    },
    {
        "label": "UniformRandomSampler",
        "importPath": "robosuite.utils.placement_samplers",
        "description": "robosuite.utils.placement_samplers",
        "isExtraImport": true,
        "detail": "robosuite.utils.placement_samplers",
        "documentation": {}
    },
    {
        "label": "UniformRandomSampler",
        "importPath": "robosuite.utils.placement_samplers",
        "description": "robosuite.utils.placement_samplers",
        "isExtraImport": true,
        "detail": "robosuite.utils.placement_samplers",
        "documentation": {}
    },
    {
        "label": "SequentialCompositeSampler",
        "importPath": "robosuite.utils.placement_samplers",
        "description": "robosuite.utils.placement_samplers",
        "isExtraImport": true,
        "detail": "robosuite.utils.placement_samplers",
        "documentation": {}
    },
    {
        "label": "UniformRandomSampler",
        "importPath": "robosuite.utils.placement_samplers",
        "description": "robosuite.utils.placement_samplers",
        "isExtraImport": true,
        "detail": "robosuite.utils.placement_samplers",
        "documentation": {}
    },
    {
        "label": "UniformRandomSampler",
        "importPath": "robosuite.utils.placement_samplers",
        "description": "robosuite.utils.placement_samplers",
        "isExtraImport": true,
        "detail": "robosuite.utils.placement_samplers",
        "documentation": {}
    },
    {
        "label": "SequentialCompositeSampler",
        "importPath": "robosuite.utils.placement_samplers",
        "description": "robosuite.utils.placement_samplers",
        "isExtraImport": true,
        "detail": "robosuite.utils.placement_samplers",
        "documentation": {}
    },
    {
        "label": "UniformRandomSampler",
        "importPath": "robosuite.utils.placement_samplers",
        "description": "robosuite.utils.placement_samplers",
        "isExtraImport": true,
        "detail": "robosuite.utils.placement_samplers",
        "documentation": {}
    },
    {
        "label": "UniformRandomSampler",
        "importPath": "robosuite.utils.placement_samplers",
        "description": "robosuite.utils.placement_samplers",
        "isExtraImport": true,
        "detail": "robosuite.utils.placement_samplers",
        "documentation": {}
    },
    {
        "label": "RandomizationError",
        "importPath": "robosuite.utils",
        "description": "robosuite.utils",
        "isExtraImport": true,
        "detail": "robosuite.utils",
        "documentation": {}
    },
    {
        "label": "SimulationError",
        "importPath": "robosuite.utils",
        "description": "robosuite.utils",
        "isExtraImport": true,
        "detail": "robosuite.utils",
        "documentation": {}
    },
    {
        "label": "XMLError",
        "importPath": "robosuite.utils",
        "description": "robosuite.utils",
        "isExtraImport": true,
        "detail": "robosuite.utils",
        "documentation": {}
    },
    {
        "label": "MujocoPyRenderer",
        "importPath": "robosuite.utils",
        "description": "robosuite.utils",
        "isExtraImport": true,
        "detail": "robosuite.utils",
        "documentation": {}
    },
    {
        "label": "XMLError",
        "importPath": "robosuite.utils",
        "description": "robosuite.utils",
        "isExtraImport": true,
        "detail": "robosuite.utils",
        "documentation": {}
    },
    {
        "label": "RandomizationError",
        "importPath": "robosuite.utils",
        "description": "robosuite.utils",
        "isExtraImport": true,
        "detail": "robosuite.utils",
        "documentation": {}
    },
    {
        "label": "RobotEnv",
        "importPath": "robosuite.environments.robot_env",
        "description": "robosuite.environments.robot_env",
        "isExtraImport": true,
        "detail": "robosuite.environments.robot_env",
        "documentation": {}
    },
    {
        "label": "MujocoModel",
        "importPath": "robosuite.models.base",
        "description": "robosuite.models.base",
        "isExtraImport": true,
        "detail": "robosuite.models.base",
        "documentation": {}
    },
    {
        "label": "MujocoModel",
        "importPath": "robosuite.models.base",
        "description": "robosuite.models.base",
        "isExtraImport": true,
        "detail": "robosuite.models.base",
        "documentation": {}
    },
    {
        "label": "MujocoXML",
        "importPath": "robosuite.models.base",
        "description": "robosuite.models.base",
        "isExtraImport": true,
        "detail": "robosuite.models.base",
        "documentation": {}
    },
    {
        "label": "MujocoXMLModel",
        "importPath": "robosuite.models.base",
        "description": "robosuite.models.base",
        "isExtraImport": true,
        "detail": "robosuite.models.base",
        "documentation": {}
    },
    {
        "label": "MujocoXMLModel",
        "importPath": "robosuite.models.base",
        "description": "robosuite.models.base",
        "isExtraImport": true,
        "detail": "robosuite.models.base",
        "documentation": {}
    },
    {
        "label": "MujocoXML",
        "importPath": "robosuite.models.base",
        "description": "robosuite.models.base",
        "isExtraImport": true,
        "detail": "robosuite.models.base",
        "documentation": {}
    },
    {
        "label": "MujocoModel",
        "importPath": "robosuite.models.base",
        "description": "robosuite.models.base",
        "isExtraImport": true,
        "detail": "robosuite.models.base",
        "documentation": {}
    },
    {
        "label": "MujocoXMLModel",
        "importPath": "robosuite.models.base",
        "description": "robosuite.models.base",
        "isExtraImport": true,
        "detail": "robosuite.models.base",
        "documentation": {}
    },
    {
        "label": "MujocoXML",
        "importPath": "robosuite.models.base",
        "description": "robosuite.models.base",
        "isExtraImport": true,
        "detail": "robosuite.models.base",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "PegObject",
        "importPath": "robosuite.models.objects.xml_objects",
        "description": "robosuite.models.objects.xml_objects",
        "isExtraImport": true,
        "detail": "robosuite.models.objects.xml_objects",
        "documentation": {}
    },
    {
        "label": "ManipulationEnv",
        "importPath": "robosuite.environments.manipulation.manipulation_env",
        "description": "robosuite.environments.manipulation.manipulation_env",
        "isExtraImport": true,
        "detail": "robosuite.environments.manipulation.manipulation_env",
        "documentation": {}
    },
    {
        "label": "multiprocessing",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "MujocoEnv",
        "importPath": "robosuite.environments.base",
        "description": "robosuite.environments.base",
        "isExtraImport": true,
        "detail": "robosuite.environments.base",
        "documentation": {}
    },
    {
        "label": "SkillController",
        "importPath": "robosuite.controllers.skill_controller",
        "description": "robosuite.controllers.skill_controller",
        "isExtraImport": true,
        "detail": "robosuite.controllers.skill_controller",
        "documentation": {}
    },
    {
        "label": "MujocoWorldBase",
        "importPath": "robosuite.models.world",
        "description": "robosuite.models.world",
        "isExtraImport": true,
        "detail": "robosuite.models.world",
        "documentation": {}
    },
    {
        "label": "MujocoWorldBase",
        "importPath": "robosuite.models.world",
        "description": "robosuite.models.world",
        "isExtraImport": true,
        "detail": "robosuite.models.world",
        "documentation": {}
    },
    {
        "label": "GripperModel",
        "importPath": "robosuite.models.grippers.gripper_model",
        "description": "robosuite.models.grippers.gripper_model",
        "isExtraImport": true,
        "detail": "robosuite.models.grippers.gripper_model",
        "documentation": {}
    },
    {
        "label": "GripperModel",
        "importPath": "robosuite.models.grippers.gripper_model",
        "description": "robosuite.models.grippers.gripper_model",
        "isExtraImport": true,
        "detail": "robosuite.models.grippers.gripper_model",
        "documentation": {}
    },
    {
        "label": "GripperModel",
        "importPath": "robosuite.models.grippers.gripper_model",
        "description": "robosuite.models.grippers.gripper_model",
        "isExtraImport": true,
        "detail": "robosuite.models.grippers.gripper_model",
        "documentation": {}
    },
    {
        "label": "GripperModel",
        "importPath": "robosuite.models.grippers.gripper_model",
        "description": "robosuite.models.grippers.gripper_model",
        "isExtraImport": true,
        "detail": "robosuite.models.grippers.gripper_model",
        "documentation": {}
    },
    {
        "label": "GripperModel",
        "importPath": "robosuite.models.grippers.gripper_model",
        "description": "robosuite.models.grippers.gripper_model",
        "isExtraImport": true,
        "detail": "robosuite.models.grippers.gripper_model",
        "documentation": {}
    },
    {
        "label": "GripperModel",
        "importPath": "robosuite.models.grippers.gripper_model",
        "description": "robosuite.models.grippers.gripper_model",
        "isExtraImport": true,
        "detail": "robosuite.models.grippers.gripper_model",
        "documentation": {}
    },
    {
        "label": "GripperModel",
        "importPath": "robosuite.models.grippers.gripper_model",
        "description": "robosuite.models.grippers.gripper_model",
        "isExtraImport": true,
        "detail": "robosuite.models.grippers.gripper_model",
        "documentation": {}
    },
    {
        "label": "GripperModel",
        "importPath": "robosuite.models.grippers.gripper_model",
        "description": "robosuite.models.grippers.gripper_model",
        "isExtraImport": true,
        "detail": "robosuite.models.grippers.gripper_model",
        "documentation": {}
    },
    {
        "label": "MountModel",
        "importPath": "robosuite.models.mounts.mount_model",
        "description": "robosuite.models.mounts.mount_model",
        "isExtraImport": true,
        "detail": "robosuite.models.mounts.mount_model",
        "documentation": {}
    },
    {
        "label": "MountModel",
        "importPath": "robosuite.models.mounts.mount_model",
        "description": "robosuite.models.mounts.mount_model",
        "isExtraImport": true,
        "detail": "robosuite.models.mounts.mount_model",
        "documentation": {}
    },
    {
        "label": "MountModel",
        "importPath": "robosuite.models.mounts.mount_model",
        "description": "robosuite.models.mounts.mount_model",
        "isExtraImport": true,
        "detail": "robosuite.models.mounts.mount_model",
        "documentation": {}
    },
    {
        "label": "ManipulatorModel",
        "importPath": "robosuite.models.robots.manipulators.manipulator_model",
        "description": "robosuite.models.robots.manipulators.manipulator_model",
        "isExtraImport": true,
        "detail": "robosuite.models.robots.manipulators.manipulator_model",
        "documentation": {}
    },
    {
        "label": "ManipulatorModel",
        "importPath": "robosuite.models.robots.manipulators.manipulator_model",
        "description": "robosuite.models.robots.manipulators.manipulator_model",
        "isExtraImport": true,
        "detail": "robosuite.models.robots.manipulators.manipulator_model",
        "documentation": {}
    },
    {
        "label": "ManipulatorModel",
        "importPath": "robosuite.models.robots.manipulators.manipulator_model",
        "description": "robosuite.models.robots.manipulators.manipulator_model",
        "isExtraImport": true,
        "detail": "robosuite.models.robots.manipulators.manipulator_model",
        "documentation": {}
    },
    {
        "label": "ManipulatorModel",
        "importPath": "robosuite.models.robots.manipulators.manipulator_model",
        "description": "robosuite.models.robots.manipulators.manipulator_model",
        "isExtraImport": true,
        "detail": "robosuite.models.robots.manipulators.manipulator_model",
        "documentation": {}
    },
    {
        "label": "ManipulatorModel",
        "importPath": "robosuite.models.robots.manipulators.manipulator_model",
        "description": "robosuite.models.robots.manipulators.manipulator_model",
        "isExtraImport": true,
        "detail": "robosuite.models.robots.manipulators.manipulator_model",
        "documentation": {}
    },
    {
        "label": "ManipulatorModel",
        "importPath": "robosuite.models.robots.manipulators.manipulator_model",
        "description": "robosuite.models.robots.manipulators.manipulator_model",
        "isExtraImport": true,
        "detail": "robosuite.models.robots.manipulators.manipulator_model",
        "documentation": {}
    },
    {
        "label": "ManipulatorModel",
        "importPath": "robosuite.models.robots.manipulators.manipulator_model",
        "description": "robosuite.models.robots.manipulators.manipulator_model",
        "isExtraImport": true,
        "detail": "robosuite.models.robots.manipulators.manipulator_model",
        "documentation": {}
    },
    {
        "label": "RobotModel",
        "importPath": "robosuite.models.robots",
        "description": "robosuite.models.robots",
        "isExtraImport": true,
        "detail": "robosuite.models.robots",
        "documentation": {}
    },
    {
        "label": "RobotModel",
        "importPath": "robosuite.models.robots",
        "description": "robosuite.models.robots",
        "isExtraImport": true,
        "detail": "robosuite.models.robots",
        "documentation": {}
    },
    {
        "label": "create_robot",
        "importPath": "robosuite.models.robots",
        "description": "robosuite.models.robots",
        "isExtraImport": true,
        "detail": "robosuite.models.robots",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "robosuite.models.robots",
        "description": "robosuite.models.robots",
        "isExtraImport": true,
        "detail": "robosuite.models.robots",
        "documentation": {}
    },
    {
        "label": "Task",
        "importPath": "robosuite.models.tasks.task",
        "description": "robosuite.models.tasks.task",
        "isExtraImport": true,
        "detail": "robosuite.models.tasks.task",
        "documentation": {}
    },
    {
        "label": "xml.dom.minidom",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "xml.dom.minidom",
        "description": "xml.dom.minidom",
        "detail": "xml.dom.minidom",
        "documentation": {}
    },
    {
        "label": "io",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "io",
        "description": "io",
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "Manipulator",
        "importPath": "robosuite.robots.manipulator",
        "description": "robosuite.robots.manipulator",
        "isExtraImport": true,
        "detail": "robosuite.robots.manipulator",
        "documentation": {}
    },
    {
        "label": "Manipulator",
        "importPath": "robosuite.robots.manipulator",
        "description": "robosuite.robots.manipulator",
        "isExtraImport": true,
        "detail": "robosuite.robots.manipulator",
        "documentation": {}
    },
    {
        "label": "Robot",
        "importPath": "robosuite.robots.robot",
        "description": "robosuite.robots.robot",
        "isExtraImport": true,
        "detail": "robosuite.robots.robot",
        "documentation": {}
    },
    {
        "label": "mount_factory",
        "importPath": "robosuite.models.mounts",
        "description": "robosuite.models.mounts",
        "isExtraImport": true,
        "detail": "robosuite.models.mounts",
        "documentation": {}
    },
    {
        "label": "shutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shutil",
        "description": "shutil",
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "copyfile",
        "importPath": "shutil",
        "description": "shutil",
        "isExtraImport": true,
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "datetime",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "datetime",
        "description": "datetime",
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "h5py",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "h5py",
        "description": "h5py",
        "detail": "h5py",
        "documentation": {}
    },
    {
        "label": "GymWrapper",
        "importPath": "robosuite.wrappers.gym_wrapper",
        "description": "robosuite.wrappers.gym_wrapper",
        "isExtraImport": true,
        "detail": "robosuite.wrappers.gym_wrapper",
        "documentation": {}
    },
    {
        "label": "jit_decorator",
        "importPath": "robosuite.utils.numba",
        "description": "robosuite.utils.numba",
        "isExtraImport": true,
        "detail": "robosuite.utils.numba",
        "documentation": {}
    },
    {
        "label": "jit_decorator",
        "importPath": "robosuite.utils.numba",
        "description": "robosuite.utils.numba",
        "isExtraImport": true,
        "detail": "robosuite.utils.numba",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "const",
        "importPath": "mujoco_py.generated",
        "description": "mujoco_py.generated",
        "isExtraImport": true,
        "detail": "mujoco_py.generated",
        "documentation": {}
    },
    {
        "label": "numba",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numba",
        "description": "numba",
        "detail": "numba",
        "documentation": {}
    },
    {
        "label": "TextureModder",
        "importPath": "robosuite.utils.mjmod",
        "description": "robosuite.utils.mjmod",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjmod",
        "documentation": {}
    },
    {
        "label": "LightingModder",
        "importPath": "robosuite.utils.mjmod",
        "description": "robosuite.utils.mjmod",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjmod",
        "documentation": {}
    },
    {
        "label": "CameraModder",
        "importPath": "robosuite.utils.mjmod",
        "description": "robosuite.utils.mjmod",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjmod",
        "documentation": {}
    },
    {
        "label": "spaces",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "Env",
        "importPath": "gym.core",
        "description": "gym.core",
        "isExtraImport": true,
        "detail": "gym.core",
        "documentation": {}
    },
    {
        "label": "setup",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "find_packages",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "extensions",
        "kind": 5,
        "importPath": "docs.conf",
        "description": "docs.conf",
        "peekOfCode": "extensions = [\n    'sphinx.ext.napoleon',\n    'sphinx_rtd_theme',\n    'sphinx_markdown_tables',\n    'sphinx.ext.mathjax',\n    'sphinx.ext.githubpages',\n    'sphinx.ext.autodoc',\n    'recommonmark', # use Sphinx-1.4 or newer\n    'nbsphinx',\n]",
        "detail": "docs.conf",
        "documentation": {}
    },
    {
        "label": "apidoc_module_dir",
        "kind": 5,
        "importPath": "docs.conf",
        "description": "docs.conf",
        "peekOfCode": "apidoc_module_dir = \"../robosuite\"\napidoc_output_dir = \"reference\"\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = ['_templates']\n# source_parsers = {\n#     '.md': CommonMarkParser,\n# }\n# The suffix(es) of source filenames.\n# You can specify multiple suffix as a list of string:\nsource_suffix = ['.rst', '.md', '.ipynb']",
        "detail": "docs.conf",
        "documentation": {}
    },
    {
        "label": "apidoc_output_dir",
        "kind": 5,
        "importPath": "docs.conf",
        "description": "docs.conf",
        "peekOfCode": "apidoc_output_dir = \"reference\"\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = ['_templates']\n# source_parsers = {\n#     '.md': CommonMarkParser,\n# }\n# The suffix(es) of source filenames.\n# You can specify multiple suffix as a list of string:\nsource_suffix = ['.rst', '.md', '.ipynb']\n# The master toctree document.",
        "detail": "docs.conf",
        "documentation": {}
    },
    {
        "label": "templates_path",
        "kind": 5,
        "importPath": "docs.conf",
        "description": "docs.conf",
        "peekOfCode": "templates_path = ['_templates']\n# source_parsers = {\n#     '.md': CommonMarkParser,\n# }\n# The suffix(es) of source filenames.\n# You can specify multiple suffix as a list of string:\nsource_suffix = ['.rst', '.md', '.ipynb']\n# The master toctree document.\nmaster_doc = 'index'\n# General information about the project.",
        "detail": "docs.conf",
        "documentation": {}
    },
    {
        "label": "source_suffix",
        "kind": 5,
        "importPath": "docs.conf",
        "description": "docs.conf",
        "peekOfCode": "source_suffix = ['.rst', '.md', '.ipynb']\n# The master toctree document.\nmaster_doc = 'index'\n# General information about the project.\nproject = u'robosuite'\ncopyright = u'Stanford Univeristy and The University of Texas at Austin 2020'\nauthor = u'Yuke Zhu, Josiah Wong, Jiren Zhu, Ajay Mandlekar, Roberto Martn-Martn'\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.",
        "detail": "docs.conf",
        "documentation": {}
    },
    {
        "label": "master_doc",
        "kind": 5,
        "importPath": "docs.conf",
        "description": "docs.conf",
        "peekOfCode": "master_doc = 'index'\n# General information about the project.\nproject = u'robosuite'\ncopyright = u'Stanford Univeristy and The University of Texas at Austin 2020'\nauthor = u'Yuke Zhu, Josiah Wong, Jiren Zhu, Ajay Mandlekar, Roberto Martn-Martn'\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.",
        "detail": "docs.conf",
        "documentation": {}
    },
    {
        "label": "project",
        "kind": 5,
        "importPath": "docs.conf",
        "description": "docs.conf",
        "peekOfCode": "project = u'robosuite'\ncopyright = u'Stanford Univeristy and The University of Texas at Austin 2020'\nauthor = u'Yuke Zhu, Josiah Wong, Jiren Zhu, Ajay Mandlekar, Roberto Martn-Martn'\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\nversion = robosuite.__version__\n# The full version, including alpha/beta/rc tags.",
        "detail": "docs.conf",
        "documentation": {}
    },
    {
        "label": "copyright",
        "kind": 5,
        "importPath": "docs.conf",
        "description": "docs.conf",
        "peekOfCode": "copyright = u'Stanford Univeristy and The University of Texas at Austin 2020'\nauthor = u'Yuke Zhu, Josiah Wong, Jiren Zhu, Ajay Mandlekar, Roberto Martn-Martn'\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\nversion = robosuite.__version__\n# The full version, including alpha/beta/rc tags.\nrelease = robosuite.__version__",
        "detail": "docs.conf",
        "documentation": {}
    },
    {
        "label": "author",
        "kind": 5,
        "importPath": "docs.conf",
        "description": "docs.conf",
        "peekOfCode": "author = u'Yuke Zhu, Josiah Wong, Jiren Zhu, Ajay Mandlekar, Roberto Martn-Martn'\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\nversion = robosuite.__version__\n# The full version, including alpha/beta/rc tags.\nrelease = robosuite.__version__\n# The language for content autogenerated by Sphinx. Refer to documentation",
        "detail": "docs.conf",
        "documentation": {}
    },
    {
        "label": "version",
        "kind": 5,
        "importPath": "docs.conf",
        "description": "docs.conf",
        "peekOfCode": "version = robosuite.__version__\n# The full version, including alpha/beta/rc tags.\nrelease = robosuite.__version__\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#\n# This is also used if you do content translation via gettext catalogs.\n# Usually you set \"language\" from the command line for these cases.\nlanguage = None\n# List of patterns, relative to source directory, that match files and",
        "detail": "docs.conf",
        "documentation": {}
    },
    {
        "label": "release",
        "kind": 5,
        "importPath": "docs.conf",
        "description": "docs.conf",
        "peekOfCode": "release = robosuite.__version__\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#\n# This is also used if you do content translation via gettext catalogs.\n# Usually you set \"language\" from the command line for these cases.\nlanguage = None\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\n# This patterns also effect to html_static_path and html_extra_path",
        "detail": "docs.conf",
        "documentation": {}
    },
    {
        "label": "language",
        "kind": 5,
        "importPath": "docs.conf",
        "description": "docs.conf",
        "peekOfCode": "language = None\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\n# This patterns also effect to html_static_path and html_extra_path\nexclude_patterns = ['_build', 'Thumbs.db', '.DS_Store']\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = 'sphinx'\n# If true, `todo` and `todoList` produce output, else they produce nothing.\ntodo_include_todos = False\n# -- Options for HTML output ----------------------------------------------",
        "detail": "docs.conf",
        "documentation": {}
    },
    {
        "label": "exclude_patterns",
        "kind": 5,
        "importPath": "docs.conf",
        "description": "docs.conf",
        "peekOfCode": "exclude_patterns = ['_build', 'Thumbs.db', '.DS_Store']\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = 'sphinx'\n# If true, `todo` and `todoList` produce output, else they produce nothing.\ntodo_include_todos = False\n# -- Options for HTML output ----------------------------------------------\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\n#\nhtml_theme = 'sphinx_rtd_theme'",
        "detail": "docs.conf",
        "documentation": {}
    },
    {
        "label": "pygments_style",
        "kind": 5,
        "importPath": "docs.conf",
        "description": "docs.conf",
        "peekOfCode": "pygments_style = 'sphinx'\n# If true, `todo` and `todoList` produce output, else they produce nothing.\ntodo_include_todos = False\n# -- Options for HTML output ----------------------------------------------\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\n#\nhtml_theme = 'sphinx_rtd_theme'\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the",
        "detail": "docs.conf",
        "documentation": {}
    },
    {
        "label": "todo_include_todos",
        "kind": 5,
        "importPath": "docs.conf",
        "description": "docs.conf",
        "peekOfCode": "todo_include_todos = False\n# -- Options for HTML output ----------------------------------------------\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\n#\nhtml_theme = 'sphinx_rtd_theme'\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\n#",
        "detail": "docs.conf",
        "documentation": {}
    },
    {
        "label": "html_theme",
        "kind": 5,
        "importPath": "docs.conf",
        "description": "docs.conf",
        "peekOfCode": "html_theme = 'sphinx_rtd_theme'\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\n#\n# html_theme_options = {}\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named \"default.css\" will overwrite the builtin \"default.css\".\nhtml_static_path = ['_static']",
        "detail": "docs.conf",
        "documentation": {}
    },
    {
        "label": "html_static_path",
        "kind": 5,
        "importPath": "docs.conf",
        "description": "docs.conf",
        "peekOfCode": "html_static_path = ['_static']\nhtml_context = {\n    'css_files': [\n        '_static/theme_overrides.css',  # override wide tables in RTD theme\n    ],\n}\n# -- Options for HTMLHelp output ------------------------------------------\n# Output file base name for HTML help builder.\nhtmlhelp_basename = 'robosuitedoc'\n# -- Options for LaTeX output ---------------------------------------------",
        "detail": "docs.conf",
        "documentation": {}
    },
    {
        "label": "html_context",
        "kind": 5,
        "importPath": "docs.conf",
        "description": "docs.conf",
        "peekOfCode": "html_context = {\n    'css_files': [\n        '_static/theme_overrides.css',  # override wide tables in RTD theme\n    ],\n}\n# -- Options for HTMLHelp output ------------------------------------------\n# Output file base name for HTML help builder.\nhtmlhelp_basename = 'robosuitedoc'\n# -- Options for LaTeX output ---------------------------------------------\nlatex_elements = {",
        "detail": "docs.conf",
        "documentation": {}
    },
    {
        "label": "htmlhelp_basename",
        "kind": 5,
        "importPath": "docs.conf",
        "description": "docs.conf",
        "peekOfCode": "htmlhelp_basename = 'robosuitedoc'\n# -- Options for LaTeX output ---------------------------------------------\nlatex_elements = {\n    # The paper size ('letterpaper' or 'a4paper').\n    #\n    # 'papersize': 'letterpaper',\n    # The font size ('10pt', '11pt' or '12pt').\n    #\n    # 'pointsize': '10pt',\n    # Additional stuff for the LaTeX preamble.",
        "detail": "docs.conf",
        "documentation": {}
    },
    {
        "label": "latex_elements",
        "kind": 5,
        "importPath": "docs.conf",
        "description": "docs.conf",
        "peekOfCode": "latex_elements = {\n    # The paper size ('letterpaper' or 'a4paper').\n    #\n    # 'papersize': 'letterpaper',\n    # The font size ('10pt', '11pt' or '12pt').\n    #\n    # 'pointsize': '10pt',\n    # Additional stuff for the LaTeX preamble.\n    #\n    # 'preamble': '',",
        "detail": "docs.conf",
        "documentation": {}
    },
    {
        "label": "latex_documents",
        "kind": 5,
        "importPath": "docs.conf",
        "description": "docs.conf",
        "peekOfCode": "latex_documents = [\n    (master_doc, 'robosuite.tex', u'robosuite Documentation', author, 'manual'),\n]\n# -- Options for manual page output ---------------------------------------\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [\n    (master_doc, 'robosuite', u'robosuite Documentation',\n     [author], 1)\n]",
        "detail": "docs.conf",
        "documentation": {}
    },
    {
        "label": "man_pages",
        "kind": 5,
        "importPath": "docs.conf",
        "description": "docs.conf",
        "peekOfCode": "man_pages = [\n    (master_doc, 'robosuite', u'robosuite Documentation',\n     [author], 1)\n]\n# -- Options for Texinfo output -------------------------------------------\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [\n    (master_doc, 'robosuite', u'robosuite Documentation',",
        "detail": "docs.conf",
        "documentation": {}
    },
    {
        "label": "texinfo_documents",
        "kind": 5,
        "importPath": "docs.conf",
        "description": "docs.conf",
        "peekOfCode": "texinfo_documents = [\n    (master_doc, 'robosuite', u'robosuite Documentation',\n     author, 'robosuite', 'ARISE',\n     'Miscellaneous'),\n]",
        "detail": "docs.conf",
        "documentation": {}
    },
    {
        "label": "Interpolator",
        "kind": 6,
        "importPath": "robosuite.controllers.interpolators.base_interpolator",
        "description": "robosuite.controllers.interpolators.base_interpolator",
        "peekOfCode": "class Interpolator(object, metaclass=abc.ABCMeta):\n    \"\"\"\n    General interpolator interface.\n    \"\"\"\n    @abc.abstractmethod\n    def get_interpolated_goal(self):\n        \"\"\"\n        Provides the next step in interpolation given the remaining steps.\n        Returns:\n            np.array: Next interpolated step",
        "detail": "robosuite.controllers.interpolators.base_interpolator",
        "documentation": {}
    },
    {
        "label": "LinearInterpolator",
        "kind": 6,
        "importPath": "robosuite.controllers.interpolators.linear_interpolator",
        "description": "robosuite.controllers.interpolators.linear_interpolator",
        "peekOfCode": "class LinearInterpolator(Interpolator):\n    \"\"\"\n    Simple class for implementing a linear interpolator.\n    Abstracted to interpolate n-dimensions\n    Args:\n        ndim (int): Number of dimensions to interpolate\n        controller_freq (float): Frequency (Hz) of the controller\n        policy_freq (float): Frequency (Hz) of the policy model\n        ramp_ratio (float): Percentage of interpolation timesteps across which we will interpolate to a goal position.\n            :Note: Num total interpolation steps will be equal to np.floor(ramp_ratio * controller_freq / policy_freq)",
        "detail": "robosuite.controllers.interpolators.linear_interpolator",
        "documentation": {}
    },
    {
        "label": "Controller",
        "kind": 6,
        "importPath": "robosuite.controllers.base_controller",
        "description": "robosuite.controllers.base_controller",
        "peekOfCode": "class Controller(object, metaclass=abc.ABCMeta):\n    \"\"\"\n    General controller interface.\n    Requires reference to mujoco sim object, eef_name of specific robot, relevant joint_indexes to that robot, and\n    whether an initial_joint is used for nullspace torques or not\n    Args:\n        sim (MjSim): Simulator instance this controller will pull robot state updates from\n        eef_name (str): Name of controlled robot arm's end effector (from robot XML)\n        joint_indexes (dict): Each key contains sim reference indexes to relevant robot joint information, namely:\n            :`'joints'`: list of indexes to relevant robot joints",
        "detail": "robosuite.controllers.base_controller",
        "documentation": {}
    },
    {
        "label": "reset_controllers",
        "kind": 2,
        "importPath": "robosuite.controllers.controller_factory",
        "description": "robosuite.controllers.controller_factory",
        "peekOfCode": "def reset_controllers():\n    \"\"\"\n    Global function for doing one-time clears and restarting of any global controller-related\n    specifics before re-initializing each individual controller again\n    \"\"\"\n    global pybullet_server\n    # Disconnect and reconnect to pybullet server if it exists\n    if pybullet_server is not None:\n        pybullet_server.disconnect()\n        pybullet_server.connect()",
        "detail": "robosuite.controllers.controller_factory",
        "documentation": {}
    },
    {
        "label": "get_pybullet_server",
        "kind": 2,
        "importPath": "robosuite.controllers.controller_factory",
        "description": "robosuite.controllers.controller_factory",
        "peekOfCode": "def get_pybullet_server():\n    \"\"\"\n    Getter to return reference to pybullet server module variable\n    Returns:\n        PyBulletServer: Server instance running PyBullet\n    \"\"\"\n    global pybullet_server\n    return pybullet_server\ndef load_controller_config(custom_fpath=None, default_controller=None):\n    \"\"\"",
        "detail": "robosuite.controllers.controller_factory",
        "documentation": {}
    },
    {
        "label": "load_controller_config",
        "kind": 2,
        "importPath": "robosuite.controllers.controller_factory",
        "description": "robosuite.controllers.controller_factory",
        "peekOfCode": "def load_controller_config(custom_fpath=None, default_controller=None):\n    \"\"\"\n    Utility function that loads the desired controller and returns the loaded configuration as a dict\n    If @default_controller is specified, any value inputted to @custom_fpath is overridden and the default controller\n    configuration is automatically loaded. See specific arg description below for available default controllers.\n    Args:\n        custom_fpath (str): Absolute filepath to the custom controller configuration .json file to be loaded\n        default_controller (str): If specified, overrides @custom_fpath and loads a default configuration file for the\n            specified controller.\n            Choices are: {\"JOINT_POSITION\", \"JOINT_TORQUE\", \"JOINT_VELOCITY\", \"OSC_POSITION\", \"OSC_POSE\", \"IK_POSE\"}",
        "detail": "robosuite.controllers.controller_factory",
        "documentation": {}
    },
    {
        "label": "controller_factory",
        "kind": 2,
        "importPath": "robosuite.controllers.controller_factory",
        "description": "robosuite.controllers.controller_factory",
        "peekOfCode": "def controller_factory(name, params):\n    \"\"\"\n    Generator for controllers\n    Creates a Controller instance with the provided @name and relevant @params.\n    Args:\n        name (str): the name of the controller. Must be one of: {JOINT_POSITION, JOINT_TORQUE, JOINT_VELOCITY,\n            OSC_POSITION, OSC_POSE, IK_POSE}\n        params (dict): dict containing the relevant params to pass to the controller\n        sim (MjSim): Mujoco sim reference to pass to the controller\n    Returns:",
        "detail": "robosuite.controllers.controller_factory",
        "documentation": {}
    },
    {
        "label": "pybullet_server",
        "kind": 5,
        "importPath": "robosuite.controllers.controller_factory",
        "description": "robosuite.controllers.controller_factory",
        "peekOfCode": "pybullet_server = None\ndef reset_controllers():\n    \"\"\"\n    Global function for doing one-time clears and restarting of any global controller-related\n    specifics before re-initializing each individual controller again\n    \"\"\"\n    global pybullet_server\n    # Disconnect and reconnect to pybullet server if it exists\n    if pybullet_server is not None:\n        pybullet_server.disconnect()",
        "detail": "robosuite.controllers.controller_factory",
        "documentation": {}
    },
    {
        "label": "PyBulletServer",
        "kind": 6,
        "importPath": "robosuite.controllers.ik",
        "description": "robosuite.controllers.ik",
        "peekOfCode": "class PyBulletServer(object):\n    \"\"\"\n    Helper class to encapsulate an alias for a single pybullet server\n    \"\"\"\n    def __init__(self):\n        # Attributes\n        self.server_id = None\n        self.is_active = False\n        # Bodies: Dict of <bullet_robot_id : robot_name> active in pybullet simulation\n        self.bodies = {}",
        "detail": "robosuite.controllers.ik",
        "documentation": {}
    },
    {
        "label": "InverseKinematicsController",
        "kind": 6,
        "importPath": "robosuite.controllers.ik",
        "description": "robosuite.controllers.ik",
        "peekOfCode": "class InverseKinematicsController(JointVelocityController):\n    \"\"\"\n    Controller for controlling robot arm via inverse kinematics. Allows position and orientation control of the\n    robot's end effector.\n    Inverse kinematics solving is handled by pybullet.\n    NOTE: Control input actions are assumed to be relative to the current position / orientation of the end effector\n    and are taken as the array (x_dpos, y_dpos, z_dpos, x_rot, y_rot, z_rot).\n    Args:\n        sim (MjSim): Simulator instance this controller will pull robot state updates from\n        eef_name (str): Name of controlled robot arm's end effector (from robot XML)",
        "detail": "robosuite.controllers.ik",
        "documentation": {}
    },
    {
        "label": "SUPPORTED_IK_ROBOTS",
        "kind": 5,
        "importPath": "robosuite.controllers.ik",
        "description": "robosuite.controllers.ik",
        "peekOfCode": "SUPPORTED_IK_ROBOTS = {\"Baxter\", \"Sawyer\", \"Panda\"}\nclass PyBulletServer(object):\n    \"\"\"\n    Helper class to encapsulate an alias for a single pybullet server\n    \"\"\"\n    def __init__(self):\n        # Attributes\n        self.server_id = None\n        self.is_active = False\n        # Bodies: Dict of <bullet_robot_id : robot_name> active in pybullet simulation",
        "detail": "robosuite.controllers.ik",
        "documentation": {}
    },
    {
        "label": "JointPositionController",
        "kind": 6,
        "importPath": "robosuite.controllers.joint_pos",
        "description": "robosuite.controllers.joint_pos",
        "peekOfCode": "class JointPositionController(Controller):\n    \"\"\"\n    Controller for controlling robot arm via impedance control. Allows position control of the robot's joints.\n    NOTE: Control input actions assumed to be taken relative to the current joint positions. A given action to this\n    controller is assumed to be of the form: (dpos_j0, dpos_j1, ... , dpos_jn-1) for an n-joint robot\n    Args:\n        sim (MjSim): Simulator instance this controller will pull robot state updates from\n        eef_name (str): Name of controlled robot arm's end effector (from robot XML)\n        joint_indexes (dict): Each key contains sim reference indexes to relevant robot joint information, namely:\n            :`'joints'`: list of indexes to relevant robot joints",
        "detail": "robosuite.controllers.joint_pos",
        "documentation": {}
    },
    {
        "label": "IMPEDANCE_MODES",
        "kind": 5,
        "importPath": "robosuite.controllers.joint_pos",
        "description": "robosuite.controllers.joint_pos",
        "peekOfCode": "IMPEDANCE_MODES = {\"fixed\", \"variable\", \"variable_kp\"}\nclass JointPositionController(Controller):\n    \"\"\"\n    Controller for controlling robot arm via impedance control. Allows position control of the robot's joints.\n    NOTE: Control input actions assumed to be taken relative to the current joint positions. A given action to this\n    controller is assumed to be of the form: (dpos_j0, dpos_j1, ... , dpos_jn-1) for an n-joint robot\n    Args:\n        sim (MjSim): Simulator instance this controller will pull robot state updates from\n        eef_name (str): Name of controlled robot arm's end effector (from robot XML)\n        joint_indexes (dict): Each key contains sim reference indexes to relevant robot joint information, namely:",
        "detail": "robosuite.controllers.joint_pos",
        "documentation": {}
    },
    {
        "label": "JointTorqueController",
        "kind": 6,
        "importPath": "robosuite.controllers.joint_tor",
        "description": "robosuite.controllers.joint_tor",
        "peekOfCode": "class JointTorqueController(Controller):\n    \"\"\"\n    Controller for controlling the robot arm's joint torques. As the actuators at the mujoco sim level are already\n    torque actuators, this \"controller\" usually simply \"passes through\" desired torques, though it also includes the\n    typical input / output scaling and clipping, as well as interpolator features seen in other controllers classes\n    as well\n    NOTE: Control input actions assumed to be taken as absolute joint torques. A given action to this\n    controller is assumed to be of the form: (torq_j0, torq_j1, ... , torq_jn-1) for an n-joint robot\n    Args:\n        sim (MjSim): Simulator instance this controller will pull robot state updates from",
        "detail": "robosuite.controllers.joint_tor",
        "documentation": {}
    },
    {
        "label": "JointVelocityController",
        "kind": 6,
        "importPath": "robosuite.controllers.joint_vel",
        "description": "robosuite.controllers.joint_vel",
        "peekOfCode": "class JointVelocityController(Controller):\n    \"\"\"\n    Controller for controlling the robot arm's joint velocities. This is simply a P controller with desired torques\n    (pre gravity compensation) taken to be proportional to the velocity error of the robot joints.\n    NOTE: Control input actions assumed to be taken as absolute joint velocities. A given action to this\n    controller is assumed to be of the form: (vel_j0, vel_j1, ... , vel_jn-1) for an n-joint robot\n    Args:\n        sim (MjSim): Simulator instance this controller will pull robot state updates from\n        eef_name (str): Name of controlled robot arm's end effector (from robot XML)\n        joint_indexes (dict): Each key contains sim reference indexes to relevant robot joint information, namely:",
        "detail": "robosuite.controllers.joint_vel",
        "documentation": {}
    },
    {
        "label": "OperationalSpaceController",
        "kind": 6,
        "importPath": "robosuite.controllers.osc",
        "description": "robosuite.controllers.osc",
        "peekOfCode": "class OperationalSpaceController(Controller):\n    \"\"\"\n    Controller for controlling robot arm via operational space control. Allows position and / or orientation control\n    of the robot's end effector. For detailed information as to the mathematical foundation for this controller, please\n    reference http://khatib.stanford.edu/publications/pdfs/Khatib_1987_RA.pdf\n    NOTE: Control input actions can either be taken to be relative to the current position / orientation of the\n    end effector or absolute values. In either case, a given action to this controller is assumed to be of the form:\n    (x, y, z, ax, ay, az) if controlling pos and ori or simply (x, y, z) if only controlling pos\n    Args:\n        sim (MjSim): Simulator instance this controller will pull robot state updates from",
        "detail": "robosuite.controllers.osc",
        "documentation": {}
    },
    {
        "label": "IMPEDANCE_MODES",
        "kind": 5,
        "importPath": "robosuite.controllers.osc",
        "description": "robosuite.controllers.osc",
        "peekOfCode": "IMPEDANCE_MODES = {\"fixed\", \"variable\", \"variable_kp\"}\n# TODO: Maybe better naming scheme to differentiate between input / output min / max and pos/ori limits, etc.\nclass OperationalSpaceController(Controller):\n    \"\"\"\n    Controller for controlling robot arm via operational space control. Allows position and / or orientation control\n    of the robot's end effector. For detailed information as to the mathematical foundation for this controller, please\n    reference http://khatib.stanford.edu/publications/pdfs/Khatib_1987_RA.pdf\n    NOTE: Control input actions can either be taken to be relative to the current position / orientation of the\n    end effector or absolute values. In either case, a given action to this controller is assumed to be of the form:\n    (x, y, z, ax, ay, az) if controlling pos and ori or simply (x, y, z) if only controlling pos",
        "detail": "robosuite.controllers.osc",
        "documentation": {}
    },
    {
        "label": "SkillController",
        "kind": 6,
        "importPath": "robosuite.controllers.skill_controller",
        "description": "robosuite.controllers.skill_controller",
        "peekOfCode": "class SkillController:\n    SKILL_NAMES = [\n        'atomic',\n        'reach_osc', 'reach',\n        'grasp',\n        'push',\n        'open', 'close',\n    ]\n    def __init__(\n            self,",
        "detail": "robosuite.controllers.skill_controller",
        "documentation": {}
    },
    {
        "label": "BaseSkill",
        "kind": 6,
        "importPath": "robosuite.controllers.skills",
        "description": "robosuite.controllers.skills",
        "peekOfCode": "class BaseSkill:\n    def __init__(\n            self,\n            skill_type,\n            ### common settings ###\n            global_xyz_bounds=np.array([\n                [-0.30, -0.30, 0.80],\n                [0.15, 0.30, 0.90]\n            ]),\n            delta_xyz_scale=np.array([0.15, 0.15, 0.05]),",
        "detail": "robosuite.controllers.skills",
        "documentation": {}
    },
    {
        "label": "AtomicSkill",
        "kind": 6,
        "importPath": "robosuite.controllers.skills",
        "description": "robosuite.controllers.skills",
        "peekOfCode": "class AtomicSkill(BaseSkill):\n    def __init__(\n            self,\n            skill_type,\n            use_ori_params=True,\n            use_gripper_params=True,\n            **config\n    ):\n        super().__init__(\n            skill_type,",
        "detail": "robosuite.controllers.skills",
        "documentation": {}
    },
    {
        "label": "GripperSkill",
        "kind": 6,
        "importPath": "robosuite.controllers.skills",
        "description": "robosuite.controllers.skills",
        "peekOfCode": "class GripperSkill(BaseSkill):\n    def __init__(\n            self,\n            skill_type,\n            max_ac_calls=4,\n            **config\n    ):\n        super().__init__(\n            skill_type,\n            max_ac_calls=max_ac_calls,",
        "detail": "robosuite.controllers.skills",
        "documentation": {}
    },
    {
        "label": "ReachOSCSkill",
        "kind": 6,
        "importPath": "robosuite.controllers.skills",
        "description": "robosuite.controllers.skills",
        "peekOfCode": "class ReachOSCSkill(BaseSkill):\n    def __init__(\n            self,\n            skill_type,\n            use_gripper_params=True,\n            use_ori_params=False,\n            max_ac_calls=15,\n            use_delta=False, # only applicable for skill_type=r1\n            **config\n    ):",
        "detail": "robosuite.controllers.skills",
        "documentation": {}
    },
    {
        "label": "ReachSkill",
        "kind": 6,
        "importPath": "robosuite.controllers.skills",
        "description": "robosuite.controllers.skills",
        "peekOfCode": "class ReachSkill(BaseSkill):\n    STATES = ['INIT', 'LIFTED', 'HOVERING', 'REACHED']\n    def __init__(\n            self,\n            skill_type,\n            use_gripper_params=True,\n            use_ori_params=False,\n            max_ac_calls=15,\n            **config\n    ):",
        "detail": "robosuite.controllers.skills",
        "documentation": {}
    },
    {
        "label": "GraspSkill",
        "kind": 6,
        "importPath": "robosuite.controllers.skills",
        "description": "robosuite.controllers.skills",
        "peekOfCode": "class GraspSkill(BaseSkill):\n    STATES = ['INIT', 'LIFTED', 'HOVERING', 'REACHED', 'GRASPED']\n    def __init__(\n            self,\n            skill_type,\n            use_ori_params=True,\n            max_ac_calls=15,\n            num_reach_steps=1,\n            num_grasp_steps=1,\n            **config",
        "detail": "robosuite.controllers.skills",
        "documentation": {}
    },
    {
        "label": "PushSkill",
        "kind": 6,
        "importPath": "robosuite.controllers.skills",
        "description": "robosuite.controllers.skills",
        "peekOfCode": "class PushSkill(BaseSkill):\n    STATES = ['INIT', 'LIFTED', 'HOVERING', 'REACHED', 'PUSHED']\n    def __init__(\n            self,\n            skill_type,\n            max_ac_calls=20,\n            use_ori_params=True,\n            **config\n    ):\n        super().__init__(",
        "detail": "robosuite.controllers.skills",
        "documentation": {}
    },
    {
        "label": "collect_random_trajectory",
        "kind": 2,
        "importPath": "robosuite.demos.demo_collect_and_playback_data",
        "description": "robosuite.demos.demo_collect_and_playback_data",
        "peekOfCode": "def collect_random_trajectory(env, timesteps=1000):\n    \"\"\"Run a random policy to collect trajectories.\n    The rollout trajectory is saved to files in npz format.\n    Modify the DataCollectionWrapper wrapper to add new fields or change data formats.\n    Args:\n        env (MujocoEnv): environment instance to collect trajectories from\n        timesteps(int): how many environment timesteps to run for a given trajectory\n    \"\"\"\n    env.reset()\n    dof = env.action_dim",
        "detail": "robosuite.demos.demo_collect_and_playback_data",
        "documentation": {}
    },
    {
        "label": "playback_trajectory",
        "kind": 2,
        "importPath": "robosuite.demos.demo_collect_and_playback_data",
        "description": "robosuite.demos.demo_collect_and_playback_data",
        "peekOfCode": "def playback_trajectory(env, ep_dir):\n    \"\"\"Playback data from an episode.\n    Args:\n        env (MujocoEnv): environment instance to playback trajectory in\n        ep_dir (str): The path to the directory containing data for an episode.\n    \"\"\"\n    # first reload the model from the xml\n    xml_path = os.path.join(ep_dir, \"model.xml\")\n    with open(xml_path, \"r\") as f:\n        env.reset_from_xml_string(f.read())",
        "detail": "robosuite.demos.demo_collect_and_playback_data",
        "documentation": {}
    },
    {
        "label": "macros.USING_INSTANCE_RANDOMIZATION",
        "kind": 5,
        "importPath": "robosuite.demos.demo_domain_randomization",
        "description": "robosuite.demos.demo_domain_randomization",
        "peekOfCode": "macros.USING_INSTANCE_RANDOMIZATION = True\nif __name__ == \"__main__\":\n    # Create dict to hold options that will be passed to env creation call\n    options = {}\n    # print welcome info\n    print(\"Welcome to robosuite v{}!\".format(suite.__version__))\n    print(suite.__logo__)\n    # Choose environment and add it to options\n    options[\"env_name\"] = choose_environment()\n    # If a multi-arm environment has been chosen, choose configuration and appropriate robot(s)",
        "detail": "robosuite.demos.demo_domain_randomization",
        "documentation": {}
    },
    {
        "label": "macros.IMAGE_CONVENTION",
        "kind": 5,
        "importPath": "robosuite.demos.demo_video_recording",
        "description": "robosuite.demos.demo_video_recording",
        "peekOfCode": "macros.IMAGE_CONVENTION = \"opencv\"\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--environment\", type=str, default=\"Stack\")\n    parser.add_argument(\"--robots\", nargs=\"+\", type=str, default=\"Panda\", help=\"Which robot(s) to use in the env\")\n    parser.add_argument(\"--camera\", type=str, default=\"agentview\", help=\"Name of camera to render\")\n    parser.add_argument(\"--video_path\", type=str, default=\"video.mp4\")\n    parser.add_argument(\"--timesteps\", type=int, default=500)\n    parser.add_argument(\"--height\", type=int, default=512)\n    parser.add_argument(\"--width\", type=int, default=512)",
        "detail": "robosuite.demos.demo_video_recording",
        "documentation": {}
    },
    {
        "label": "Device",
        "kind": 6,
        "importPath": "robosuite.devices.device",
        "description": "robosuite.devices.device",
        "peekOfCode": "class Device(metaclass=abc.ABCMeta):\n    \"\"\"\n    Base class for all robot controllers.\n    Defines basic interface for all controllers to adhere to.\n    \"\"\"\n    @abc.abstractmethod\n    def start_control(self):\n        \"\"\"\n        Method that should be called externally before controller can \n        start receiving commands. ",
        "detail": "robosuite.devices.device",
        "documentation": {}
    },
    {
        "label": "Keyboard",
        "kind": 6,
        "importPath": "robosuite.devices.keyboard",
        "description": "robosuite.devices.keyboard",
        "peekOfCode": "class Keyboard(Device):\n    \"\"\"\n    A minimalistic driver class for a Keyboard.\n    Args:\n        pos_sensitivity (float): Magnitude of input position command scaling\n        rot_sensitivity (float): Magnitude of scale input rotation commands scaling\n    \"\"\"\n    def __init__(self,\n                 pos_sensitivity=1.0,\n                 rot_sensitivity=1.0",
        "detail": "robosuite.devices.keyboard",
        "documentation": {}
    },
    {
        "label": "SpaceMouse",
        "kind": 6,
        "importPath": "robosuite.devices.spacemouse",
        "description": "robosuite.devices.spacemouse",
        "peekOfCode": "class SpaceMouse(Device):\n    \"\"\"\n    A minimalistic driver class for SpaceMouse with HID library.\n    Note: Use hid.enumerate() to view all USB human interface devices (HID).\n    Make sure SpaceMouse is detected before running the script.\n    You can look up its vendor/product id from this method.\n    Args:\n        vendor_id (int): HID device vendor id\n        product_id (int): HID device product id\n        pos_sensitivity (float): Magnitude of input position command scaling",
        "detail": "robosuite.devices.spacemouse",
        "documentation": {}
    },
    {
        "label": "to_int16",
        "kind": 2,
        "importPath": "robosuite.devices.spacemouse",
        "description": "robosuite.devices.spacemouse",
        "peekOfCode": "def to_int16(y1, y2):\n    \"\"\"\n    Convert two 8 bit bytes to a signed 16 bit integer.\n    Args:\n        y1 (int): 8-bit byte\n        y2 (int): 8-bit byte\n    Returns:\n        int: 16-bit integer\n    \"\"\"\n    x = (y1) | (y2 << 8)",
        "detail": "robosuite.devices.spacemouse",
        "documentation": {}
    },
    {
        "label": "scale_to_control",
        "kind": 2,
        "importPath": "robosuite.devices.spacemouse",
        "description": "robosuite.devices.spacemouse",
        "peekOfCode": "def scale_to_control(x, axis_scale=350., min_v=-1.0, max_v=1.0):\n    \"\"\"\n    Normalize raw HID readings to target range.\n    Args:\n        x (int): Raw reading from HID\n        axis_scale (float): (Inverted) scaling factor for mapping raw input value\n        min_v (float): Minimum limit after scaling\n        max_v (float): Maximum limit after scaling\n    Returns:\n        float: Clipped, scaled input from HID",
        "detail": "robosuite.devices.spacemouse",
        "documentation": {}
    },
    {
        "label": "convert",
        "kind": 2,
        "importPath": "robosuite.devices.spacemouse",
        "description": "robosuite.devices.spacemouse",
        "peekOfCode": "def convert(b1, b2):\n    \"\"\"\n    Converts SpaceMouse message to commands.\n    Args:\n        b1 (int): 8-bit byte\n        b2 (int): 8-bit byte\n    Returns:\n        float: Scaled value from Spacemouse message\n    \"\"\"\n    return scale_to_control(to_int16(b1, b2))",
        "detail": "robosuite.devices.spacemouse",
        "documentation": {}
    },
    {
        "label": "AxisSpec",
        "kind": 5,
        "importPath": "robosuite.devices.spacemouse",
        "description": "robosuite.devices.spacemouse",
        "peekOfCode": "AxisSpec = namedtuple(\"AxisSpec\", [\"channel\", \"byte1\", \"byte2\", \"scale\"])\nSPACE_MOUSE_SPEC = {\n    \"x\": AxisSpec(channel=1, byte1=1, byte2=2, scale=1),\n    \"y\": AxisSpec(channel=1, byte1=3, byte2=4, scale=-1),\n    \"z\": AxisSpec(channel=1, byte1=5, byte2=6, scale=-1),\n    \"roll\": AxisSpec(channel=1, byte1=7, byte2=8, scale=-1),\n    \"pitch\": AxisSpec(channel=1, byte1=9, byte2=10, scale=-1),\n    \"yaw\": AxisSpec(channel=1, byte1=11, byte2=12, scale=1),\n}\ndef to_int16(y1, y2):",
        "detail": "robosuite.devices.spacemouse",
        "documentation": {}
    },
    {
        "label": "SPACE_MOUSE_SPEC",
        "kind": 5,
        "importPath": "robosuite.devices.spacemouse",
        "description": "robosuite.devices.spacemouse",
        "peekOfCode": "SPACE_MOUSE_SPEC = {\n    \"x\": AxisSpec(channel=1, byte1=1, byte2=2, scale=1),\n    \"y\": AxisSpec(channel=1, byte1=3, byte2=4, scale=-1),\n    \"z\": AxisSpec(channel=1, byte1=5, byte2=6, scale=-1),\n    \"roll\": AxisSpec(channel=1, byte1=7, byte2=8, scale=-1),\n    \"pitch\": AxisSpec(channel=1, byte1=9, byte2=10, scale=-1),\n    \"yaw\": AxisSpec(channel=1, byte1=11, byte2=12, scale=1),\n}\ndef to_int16(y1, y2):\n    \"\"\"",
        "detail": "robosuite.devices.spacemouse",
        "documentation": {}
    },
    {
        "label": "Cleanup",
        "kind": 6,
        "importPath": "robosuite.environments.manipulation.cleanup",
        "description": "robosuite.environments.manipulation.cleanup",
        "peekOfCode": "class Cleanup(SingleArmEnv):\n    \"\"\"\n    This class corresponds to the stacking task for a single robot arm.\n    Args:\n        robots (str or list of str): Specification for specific robot arm(s) to be instantiated within this env\n            (e.g: \"Sawyer\" would generate one arm; [\"Panda\", \"Panda\", \"Sawyer\"] would generate three robot arms)\n            Note: Must be a single single-arm robot!\n        env_configuration (str): Specifies how to position the robots within the environment (default is \"default\").\n            For most single arm environments, this argument has no impact on the robot setup.\n        controller_configs (str or list of dict): If set, contains relevant controller parameters for creating a",
        "detail": "robosuite.environments.manipulation.cleanup",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CLEANUP_CONFIG",
        "kind": 5,
        "importPath": "robosuite.environments.manipulation.cleanup",
        "description": "robosuite.environments.manipulation.cleanup",
        "peekOfCode": "DEFAULT_CLEANUP_CONFIG = {\n    'use_pnp_rew': True,\n    'use_push_rew': True,\n    'rew_type': 'sum',\n    'num_pnp_objs': 1,\n    'num_push_objs': 1,\n    'shaped_push_rew': False,\n    'push_scale_fac': 5.0,\n}\nclass Cleanup(SingleArmEnv):",
        "detail": "robosuite.environments.manipulation.cleanup",
        "documentation": {}
    },
    {
        "label": "Door",
        "kind": 6,
        "importPath": "robosuite.environments.manipulation.door",
        "description": "robosuite.environments.manipulation.door",
        "peekOfCode": "class Door(SingleArmEnv):\n    \"\"\"\n    This class corresponds to the door opening task for a single robot arm.\n    Args:\n        robots (str or list of str): Specification for specific robot arm(s) to be instantiated within this env\n            (e.g: \"Sawyer\" would generate one arm; [\"Panda\", \"Panda\", \"Sawyer\"] would generate three robot arms)\n            Note: Must be a single single-arm robot!\n        env_configuration (str): Specifies how to position the robots within the environment (default is \"default\").\n            For most single arm environments, this argument has no impact on the robot setup.\n        controller_configs (str or list of dict): If set, contains relevant controller parameters for creating a",
        "detail": "robosuite.environments.manipulation.door",
        "documentation": {}
    },
    {
        "label": "Lift",
        "kind": 6,
        "importPath": "robosuite.environments.manipulation.lift",
        "description": "robosuite.environments.manipulation.lift",
        "peekOfCode": "class Lift(SingleArmEnv):\n    \"\"\"\n    This class corresponds to the lifting task for a single robot arm.\n    Args:\n        robots (str or list of str): Specification for specific robot arm(s) to be instantiated within this env\n            (e.g: \"Sawyer\" would generate one arm; [\"Panda\", \"Panda\", \"Sawyer\"] would generate three robot arms)\n            Note: Must be a single single-arm robot!\n        env_configuration (str): Specifies how to position the robots within the environment (default is \"default\").\n            For most single arm environments, this argument has no impact on the robot setup.\n        controller_configs (str or list of dict): If set, contains relevant controller parameters for creating a",
        "detail": "robosuite.environments.manipulation.lift",
        "documentation": {}
    },
    {
        "label": "ManipulationEnv",
        "kind": 6,
        "importPath": "robosuite.environments.manipulation.manipulation_env",
        "description": "robosuite.environments.manipulation.manipulation_env",
        "peekOfCode": "class ManipulationEnv(RobotEnv):\n    \"\"\"\n    Initializes a manipulation-specific robot environment in Mujoco.\n    Args:\n        robots: Specification for specific robot arm(s) to be instantiated within this env\n            (e.g: \"Sawyer\" would generate one arm; [\"Panda\", \"Panda\", \"Sawyer\"] would generate three robot arms)\n        env_configuration (str): Specifies how to position the robot(s) within the environment. Default is \"default\",\n            which should be interpreted accordingly by any subclasses.\n        controller_configs (str or list of dict): If set, contains relevant controller parameters for creating a\n            custom controller. Else, uses the default controller for this specific task. Should either be single",
        "detail": "robosuite.environments.manipulation.manipulation_env",
        "documentation": {}
    },
    {
        "label": "NutAssembly",
        "kind": 6,
        "importPath": "robosuite.environments.manipulation.nut_assembly",
        "description": "robosuite.environments.manipulation.nut_assembly",
        "peekOfCode": "class NutAssembly(SingleArmEnv):\n    \"\"\"\n    This class corresponds to the nut assembly task for a single robot arm.\n    Args:\n        robots (str or list of str): Specification for specific robot arm(s) to be instantiated within this env\n            (e.g: \"Sawyer\" would generate one arm; [\"Panda\", \"Panda\", \"Sawyer\"] would generate three robot arms)\n            Note: Must be a single single-arm robot!\n        env_configuration (str): Specifies how to position the robots within the environment (default is \"default\").\n            For most single arm environments, this argument has no impact on the robot setup.\n        controller_configs (str or list of dict): If set, contains relevant controller parameters for creating a",
        "detail": "robosuite.environments.manipulation.nut_assembly",
        "documentation": {}
    },
    {
        "label": "NutAssemblySingle",
        "kind": 6,
        "importPath": "robosuite.environments.manipulation.nut_assembly",
        "description": "robosuite.environments.manipulation.nut_assembly",
        "peekOfCode": "class NutAssemblySingle(NutAssembly):\n    \"\"\"\n    Easier version of task - place either one round nut or one square nut into its peg.\n    \"\"\"\n    def __init__(self, **kwargs):\n        assert \"single_object_mode\" not in kwargs, \"invalid set of arguments\"\n        super().__init__(single_object_mode=1, **kwargs)\nclass NutAssemblySquare(NutAssembly):\n    \"\"\"\n    Easier version of task - place one square nut into its peg.",
        "detail": "robosuite.environments.manipulation.nut_assembly",
        "documentation": {}
    },
    {
        "label": "NutAssemblySquare",
        "kind": 6,
        "importPath": "robosuite.environments.manipulation.nut_assembly",
        "description": "robosuite.environments.manipulation.nut_assembly",
        "peekOfCode": "class NutAssemblySquare(NutAssembly):\n    \"\"\"\n    Easier version of task - place one square nut into its peg.\n    \"\"\"\n    def __init__(self, **kwargs):\n        assert (\n                \"single_object_mode\" not in kwargs and \"nut_type\" not in kwargs\n        ), \"invalid set of arguments\"\n        super().__init__(single_object_mode=2, nut_type=\"square\", **kwargs)\nclass NutAssemblyRound(NutAssembly):",
        "detail": "robosuite.environments.manipulation.nut_assembly",
        "documentation": {}
    },
    {
        "label": "NutAssemblyRound",
        "kind": 6,
        "importPath": "robosuite.environments.manipulation.nut_assembly",
        "description": "robosuite.environments.manipulation.nut_assembly",
        "peekOfCode": "class NutAssemblyRound(NutAssembly):\n    \"\"\"\n    Easier version of task - place one round nut into its peg.\n    \"\"\"\n    def __init__(self, **kwargs):\n        assert (\n                \"single_object_mode\" not in kwargs and \"nut_type\" not in kwargs\n        ), \"invalid set of arguments\"\n        super().__init__(single_object_mode=2, nut_type=\"round\", **kwargs)\n    def _get_skill_info(self):",
        "detail": "robosuite.environments.manipulation.nut_assembly",
        "documentation": {}
    },
    {
        "label": "PegInHole",
        "kind": 6,
        "importPath": "robosuite.environments.manipulation.peg_in_hole",
        "description": "robosuite.environments.manipulation.peg_in_hole",
        "peekOfCode": "class PegInHole(SingleArmEnv):\n    \"\"\"\n    This class corresponds to the stacking task for a single robot arm.\n    Args:\n        robots (str or list of str): Specification for specific robot arm(s) to be instantiated within this env\n            (e.g: \"Sawyer\" would generate one arm; [\"Panda\", \"Panda\", \"Sawyer\"] would generate three robot arms)\n            Note: Must be a single single-arm robot!\n        env_configuration (str): Specifies how to position the robots within the environment (default is \"default\").\n            For most single arm environments, this argument has no impact on the robot setup.\n        controller_configs (str or list of dict): If set, contains relevant controller parameters for creating a",
        "detail": "robosuite.environments.manipulation.peg_in_hole",
        "documentation": {}
    },
    {
        "label": "DEFAULT_PEG_IN_HOLE_CONFIG",
        "kind": 5,
        "importPath": "robosuite.environments.manipulation.peg_in_hole",
        "description": "robosuite.environments.manipulation.peg_in_hole",
        "peekOfCode": "DEFAULT_PEG_IN_HOLE_CONFIG = {\n    'large_hole': False,\n    'd_weight': 1,\n    't_weight': 5,\n    'cos_weight': 1,\n    'scale_by_cos': True,\n    'scale_by_d': True,\n    'cos_tanh_mult': 3.0,\n    'd_tanh_mult': 15.0,\n    't_tanh_mult': 7.5,",
        "detail": "robosuite.environments.manipulation.peg_in_hole",
        "documentation": {}
    },
    {
        "label": "PickPlace",
        "kind": 6,
        "importPath": "robosuite.environments.manipulation.pick_place",
        "description": "robosuite.environments.manipulation.pick_place",
        "peekOfCode": "class PickPlace(SingleArmEnv):\n    \"\"\"\n    This class corresponds to the pick place task for a single robot arm.\n    Args:\n        robots (str or list of str): Specification for specific robot arm(s) to be instantiated within this env\n            (e.g: \"Sawyer\" would generate one arm; [\"Panda\", \"Panda\", \"Sawyer\"] would generate three robot arms)\n            Note: Must be a single single-arm robot!\n        env_configuration (str): Specifies how to position the robots within the environment (default is \"default\").\n            For most single arm environments, this argument has no impact on the robot setup.\n        controller_configs (str or list of dict): If set, contains relevant controller parameters for creating a",
        "detail": "robosuite.environments.manipulation.pick_place",
        "documentation": {}
    },
    {
        "label": "PickPlaceSingle",
        "kind": 6,
        "importPath": "robosuite.environments.manipulation.pick_place",
        "description": "robosuite.environments.manipulation.pick_place",
        "peekOfCode": "class PickPlaceSingle(PickPlace):\n    \"\"\"\n    Easier version of task - place one object into its bin.\n    A new object is sampled on every reset.\n    \"\"\"\n    def __init__(self, **kwargs):\n        assert \"single_object_mode\" not in kwargs, \"invalid set of arguments\"\n        super().__init__(single_object_mode=1, **kwargs)\nclass PickPlaceMilk(PickPlace):\n    \"\"\"",
        "detail": "robosuite.environments.manipulation.pick_place",
        "documentation": {}
    },
    {
        "label": "PickPlaceMilk",
        "kind": 6,
        "importPath": "robosuite.environments.manipulation.pick_place",
        "description": "robosuite.environments.manipulation.pick_place",
        "peekOfCode": "class PickPlaceMilk(PickPlace):\n    \"\"\"\n    Easier version of task - place one milk into its bin.\n    \"\"\"\n    def __init__(self, **kwargs):\n        assert (\n                \"single_object_mode\" not in kwargs and \"object_type\" not in kwargs\n        ), \"invalid set of arguments\"\n        super().__init__(single_object_mode=2, object_type=\"milk\", **kwargs)\nclass PickPlaceBread(PickPlace):",
        "detail": "robosuite.environments.manipulation.pick_place",
        "documentation": {}
    },
    {
        "label": "PickPlaceBread",
        "kind": 6,
        "importPath": "robosuite.environments.manipulation.pick_place",
        "description": "robosuite.environments.manipulation.pick_place",
        "peekOfCode": "class PickPlaceBread(PickPlace):\n    \"\"\"\n    Easier version of task - place one bread into its bin.\n    \"\"\"\n    def __init__(self, **kwargs):\n        assert (\n                \"single_object_mode\" not in kwargs and \"object_type\" not in kwargs\n        ), \"invalid set of arguments\"\n        super().__init__(single_object_mode=2, object_type=\"bread\", **kwargs)\nclass PickPlaceCereal(PickPlace):",
        "detail": "robosuite.environments.manipulation.pick_place",
        "documentation": {}
    },
    {
        "label": "PickPlaceCereal",
        "kind": 6,
        "importPath": "robosuite.environments.manipulation.pick_place",
        "description": "robosuite.environments.manipulation.pick_place",
        "peekOfCode": "class PickPlaceCereal(PickPlace):\n    \"\"\"\n    Easier version of task - place one cereal into its bin.\n    \"\"\"\n    def __init__(self, **kwargs):\n        assert (\n                \"single_object_mode\" not in kwargs and \"object_type\" not in kwargs\n        ), \"invalid set of arguments\"\n        super().__init__(single_object_mode=2, object_type=\"cereal\", **kwargs)\nclass PickPlaceCan(PickPlace):",
        "detail": "robosuite.environments.manipulation.pick_place",
        "documentation": {}
    },
    {
        "label": "PickPlaceCan",
        "kind": 6,
        "importPath": "robosuite.environments.manipulation.pick_place",
        "description": "robosuite.environments.manipulation.pick_place",
        "peekOfCode": "class PickPlaceCan(PickPlace):\n    \"\"\"\n    Easier version of task - place one can into its bin.\n    \"\"\"\n    def __init__(self, **kwargs):\n        assert (\n                \"single_object_mode\" not in kwargs and \"object_type\" not in kwargs\n        ), \"invalid set of arguments\"\n        super().__init__(single_object_mode=2, object_type=\"can\", **kwargs)",
        "detail": "robosuite.environments.manipulation.pick_place",
        "documentation": {}
    },
    {
        "label": "SingleArmEnv",
        "kind": 6,
        "importPath": "robosuite.environments.manipulation.single_arm_env",
        "description": "robosuite.environments.manipulation.single_arm_env",
        "peekOfCode": "class SingleArmEnv(ManipulationEnv):\n    \"\"\"\n    A manipulation environment intended for a single robot arm.\n    \"\"\"\n    def _load_model(self):\n        \"\"\"\n        Verifies correct robot model is loaded\n        \"\"\"\n        super()._load_model()\n        # Verify the correct robot has been loaded",
        "detail": "robosuite.environments.manipulation.single_arm_env",
        "documentation": {}
    },
    {
        "label": "Stack",
        "kind": 6,
        "importPath": "robosuite.environments.manipulation.stack",
        "description": "robosuite.environments.manipulation.stack",
        "peekOfCode": "class Stack(SingleArmEnv):\n    \"\"\"\n    This class corresponds to the stacking task for a single robot arm.\n    Args:\n        robots (str or list of str): Specification for specific robot arm(s) to be instantiated within this env\n            (e.g: \"Sawyer\" would generate one arm; [\"Panda\", \"Panda\", \"Sawyer\"] would generate three robot arms)\n            Note: Must be a single single-arm robot!\n        env_configuration (str): Specifies how to position the robots within the environment (default is \"default\").\n            For most single arm environments, this argument has no impact on the robot setup.\n        controller_configs (str or list of dict): If set, contains relevant controller parameters for creating a",
        "detail": "robosuite.environments.manipulation.stack",
        "documentation": {}
    },
    {
        "label": "Wipe",
        "kind": 6,
        "importPath": "robosuite.environments.manipulation.wipe",
        "description": "robosuite.environments.manipulation.wipe",
        "peekOfCode": "class Wipe(SingleArmEnv):\n    \"\"\"\n    This class corresponds to the Wiping task for a single robot arm\n    Args:\n        robots (str or list of str): Specification for specific robot arm(s) to be instantiated within this env\n            (e.g: \"Sawyer\" would generate one arm; [\"Panda\", \"Panda\", \"Sawyer\"] would generate three robot arms)\n            Note: Must be a single single-arm robot!\n        env_configuration (str): Specifies how to position the robots within the environment (default is \"default\").\n            For most single arm environments, this argument has no impact on the robot setup.\n        controller_configs (str or list of dict): If set, contains relevant controller parameters for creating a",
        "detail": "robosuite.environments.manipulation.wipe",
        "documentation": {}
    },
    {
        "label": "DEFAULT_WIPE_CONFIG",
        "kind": 5,
        "importPath": "robosuite.environments.manipulation.wipe",
        "description": "robosuite.environments.manipulation.wipe",
        "peekOfCode": "DEFAULT_WIPE_CONFIG = {\n    # settings for reward\n    \"wipe_contact_reward\": 0.05,                    # reward for contacting something with the wiping tool\n    \"distance_multiplier\": 0.05,                     # multiplier for the dense reward inversely proportional to the mean location of the pegs to wipe\n    \"distance_th_multiplier\": 5.0,                  # multiplier in the tanh function for the aforementioned reward\n    \"task_complete_reward\": 1.5,\n    \"success_th\": 1.00,\n    \"excess_force_penalty_mul\": 0.01,\n    # settings for table top\n    \"table_full_size\": [0.5, 0.8, 0.05],            # Size of tabletop",
        "detail": "robosuite.environments.manipulation.wipe",
        "documentation": {}
    },
    {
        "label": "EnvMeta",
        "kind": 6,
        "importPath": "robosuite.environments.base",
        "description": "robosuite.environments.base",
        "peekOfCode": "class EnvMeta(type):\n    \"\"\"Metaclass for registering environments\"\"\"\n    def __new__(meta, name, bases, class_dict):\n        cls = super().__new__(meta, name, bases, class_dict)\n        # List all environments that should not be registered here.\n        _unregistered_envs = [\"MujocoEnv\", \"RobotEnv\", \"ManipulationEnv\", \"SingleArmEnv\"]\n        if cls.__name__ not in _unregistered_envs:\n            register_env(cls)\n        return cls\nclass MujocoEnv(metaclass=EnvMeta):",
        "detail": "robosuite.environments.base",
        "documentation": {}
    },
    {
        "label": "MujocoEnv",
        "kind": 6,
        "importPath": "robosuite.environments.base",
        "description": "robosuite.environments.base",
        "peekOfCode": "class MujocoEnv(metaclass=EnvMeta):\n    \"\"\"\n    Initializes a Mujoco Environment.\n    Args:\n        has_renderer (bool): If true, render the simulation state in\n            a viewer instead of headless mode.\n        has_offscreen_renderer (bool): True if using off-screen rendering.\n        render_camera (str): Name of camera to render if `has_renderer` is True. Setting this value to 'None'\n            will result in the default angle being applied, which is useful as it can be dragged / panned by\n            the user using the mouse",
        "detail": "robosuite.environments.base",
        "documentation": {}
    },
    {
        "label": "register_env",
        "kind": 2,
        "importPath": "robosuite.environments.base",
        "description": "robosuite.environments.base",
        "peekOfCode": "def register_env(target_class):\n    REGISTERED_ENVS[target_class.__name__] = target_class\ndef make(env_name, *args, **kwargs):\n    \"\"\"\n    Instantiates a robosuite environment.\n    This method attempts to mirror the equivalent functionality of gym.make in a somewhat sloppy way.\n    Args:\n        env_name (str): Name of the robosuite environment to initialize\n        *args: Additional arguments to pass to the specific environment class initializer\n        **kwargs: Additional arguments to pass to the specific environment class initializer",
        "detail": "robosuite.environments.base",
        "documentation": {}
    },
    {
        "label": "make",
        "kind": 2,
        "importPath": "robosuite.environments.base",
        "description": "robosuite.environments.base",
        "peekOfCode": "def make(env_name, *args, **kwargs):\n    \"\"\"\n    Instantiates a robosuite environment.\n    This method attempts to mirror the equivalent functionality of gym.make in a somewhat sloppy way.\n    Args:\n        env_name (str): Name of the robosuite environment to initialize\n        *args: Additional arguments to pass to the specific environment class initializer\n        **kwargs: Additional arguments to pass to the specific environment class initializer\n    Returns:\n        MujocoEnv: Desired robosuite environment",
        "detail": "robosuite.environments.base",
        "documentation": {}
    },
    {
        "label": "REGISTERED_ENVS",
        "kind": 5,
        "importPath": "robosuite.environments.base",
        "description": "robosuite.environments.base",
        "peekOfCode": "REGISTERED_ENVS = {}\ndef register_env(target_class):\n    REGISTERED_ENVS[target_class.__name__] = target_class\ndef make(env_name, *args, **kwargs):\n    \"\"\"\n    Instantiates a robosuite environment.\n    This method attempts to mirror the equivalent functionality of gym.make in a somewhat sloppy way.\n    Args:\n        env_name (str): Name of the robosuite environment to initialize\n        *args: Additional arguments to pass to the specific environment class initializer",
        "detail": "robosuite.environments.base",
        "documentation": {}
    },
    {
        "label": "RobotEnv",
        "kind": 6,
        "importPath": "robosuite.environments.robot_env",
        "description": "robosuite.environments.robot_env",
        "peekOfCode": "class RobotEnv(MujocoEnv):\n    \"\"\"\n    Initializes a robot environment in Mujoco.\n    Args:\n        robots: Specification for specific robot(s) to be instantiated within this env\n        env_configuration (str): Specifies how to position the robot(s) within the environment. Default is \"default\",\n            which should be interpreted accordingly by any subclasses.\n        controller_configs (str or list of dict): If set, contains relevant controller parameters for creating a\n            custom controller. Else, uses the default controller for this specific task. Should either be single\n            dict if same controller is to be used for all robots or else it should be a list of the same length as",
        "detail": "robosuite.environments.robot_env",
        "documentation": {}
    },
    {
        "label": "Arena",
        "kind": 6,
        "importPath": "robosuite.models.arenas.arena",
        "description": "robosuite.models.arenas.arena",
        "peekOfCode": "class Arena(MujocoXML):\n    \"\"\"Base arena class.\"\"\"\n    def __init__(self, fname):\n        super().__init__(fname)\n        # Get references to floor and bottom\n        self.bottom_pos = np.zeros(3)\n        self.floor = self.worldbody.find(\"./geom[@name='floor']\")\n        # Recolor all geoms\n        recolor_collision_geoms(root=self.worldbody, rgba=ENVIRONMENT_COLLISION_COLOR,\n                                exclude=lambda e: True if e.get(\"name\", None) == \"floor\" else False)",
        "detail": "robosuite.models.arenas.arena",
        "documentation": {}
    },
    {
        "label": "BinsArena",
        "kind": 6,
        "importPath": "robosuite.models.arenas.bins_arena",
        "description": "robosuite.models.arenas.bins_arena",
        "peekOfCode": "class BinsArena(Arena):\n    \"\"\"\n    Workspace that contains two bins placed side by side.\n    Args:\n        bin1_pos (3-tuple): (x,y,z) position to place bin1\n        table_full_size (3-tuple): (L,W,H) full dimensions of the table\n        table_friction (3-tuple): (sliding, torsional, rolling) friction parameters of the table\n    \"\"\"\n    def __init__(\n        self, bin1_pos=(0.1, -0.5, 0.8), table_full_size=(0.39, 0.49, 0.82), table_friction=(1, 0.005, 0.0001)",
        "detail": "robosuite.models.arenas.bins_arena",
        "documentation": {}
    },
    {
        "label": "BlockArena",
        "kind": 6,
        "importPath": "robosuite.models.arenas.block_arena",
        "description": "robosuite.models.arenas.block_arena",
        "peekOfCode": "class BlockArena(Arena):\n    \"\"\"\n    Workspace that contains an empty table.\n    Args:\n        table_full_size (3-tuple): (L,W,H) full dimensions of the table\n        table_friction (3-tuple): (sliding, torsional, rolling) friction parameters of the table\n        table_offset (3-tuple): (x,y,z) offset from center of arena when placing table.\n            Note that the z value sets the upper limit of the table\n        has_legs (bool): whether the table has legs or not\n        xml (str): xml file to load arena",
        "detail": "robosuite.models.arenas.block_arena",
        "documentation": {}
    },
    {
        "label": "EmptyArena",
        "kind": 6,
        "importPath": "robosuite.models.arenas.empty_arena",
        "description": "robosuite.models.arenas.empty_arena",
        "peekOfCode": "class EmptyArena(Arena):\n    \"\"\"Empty workspace.\"\"\"\n    def __init__(self):\n        super().__init__(xml_path_completion(\"arenas/empty_arena.xml\"))",
        "detail": "robosuite.models.arenas.empty_arena",
        "documentation": {}
    },
    {
        "label": "PegsArena",
        "kind": 6,
        "importPath": "robosuite.models.arenas.pegs_arena",
        "description": "robosuite.models.arenas.pegs_arena",
        "peekOfCode": "class PegsArena(TableArena):\n    \"\"\"\n    Workspace that contains a tabletop with two fixed pegs.\n    Args:\n        table_full_size (3-tuple): (L,W,H) full dimensions of the table\n        table_friction (3-tuple): (sliding, torsional, rolling) friction parameters of the table\n        table_offset (3-tuple): (x,y,z) offset from center of arena when placing table.\n            Note that the z value sets the upper limit of the table\n    \"\"\"\n    def __init__(",
        "detail": "robosuite.models.arenas.pegs_arena",
        "documentation": {}
    },
    {
        "label": "TableArena",
        "kind": 6,
        "importPath": "robosuite.models.arenas.table_arena",
        "description": "robosuite.models.arenas.table_arena",
        "peekOfCode": "class TableArena(Arena):\n    \"\"\"\n    Workspace that contains an empty table.\n    Args:\n        table_full_size (3-tuple): (L,W,H) full dimensions of the table\n        table_friction (3-tuple): (sliding, torsional, rolling) friction parameters of the table\n        table_offset (3-tuple): (x,y,z) offset from center of arena when placing table.\n            Note that the z value sets the upper limit of the table\n        has_legs (bool): whether the table has legs or not\n        xml (str): xml file to load arena",
        "detail": "robosuite.models.arenas.table_arena",
        "documentation": {}
    },
    {
        "label": "WipeArena",
        "kind": 6,
        "importPath": "robosuite.models.arenas.wipe_arena",
        "description": "robosuite.models.arenas.wipe_arena",
        "peekOfCode": "class WipeArena(TableArena):\n    \"\"\"\n    Workspace that contains an empty table with visual markers on its surface.\n    Args:\n        table_full_size (3-tuple): (L,W,H) full dimensions of the table\n        table_friction (3-tuple): (sliding, torsional, rolling) friction parameters of the table\n        table_offset (3-tuple): (x,y,z) offset from center of arena when placing table.\n            Note that the z value sets the upper limit of the table\n        coverage_factor (float): Fraction of table that will be sampled for dirt placement\n        num_markers (int): Number of dirt (peg) particles to generate in a path on the table",
        "detail": "robosuite.models.arenas.wipe_arena",
        "documentation": {}
    },
    {
        "label": "gripper_factory",
        "kind": 2,
        "importPath": "robosuite.models.grippers.gripper_factory",
        "description": "robosuite.models.grippers.gripper_factory",
        "peekOfCode": "def gripper_factory(name, idn=0):\n    \"\"\"\n    Generator for grippers\n    Creates a GripperModel instance with the provided name.\n    Args:\n        name (None or str): the name of the gripper class\n        idn (int or str): Number or some other unique identification string for this gripper instance\n    Returns:\n        GripperModel: requested gripper instance\n    Raises:",
        "detail": "robosuite.models.grippers.gripper_factory",
        "documentation": {}
    },
    {
        "label": "GripperModel",
        "kind": 6,
        "importPath": "robosuite.models.grippers.gripper_model",
        "description": "robosuite.models.grippers.gripper_model",
        "peekOfCode": "class GripperModel(MujocoXMLModel):\n    \"\"\"\n    Base class for grippers\n    Args:\n        fname (str): Path to relevant xml file to create this gripper instance\n        idn (int or str): Number or some other unique identification string for this gripper instance\n    \"\"\"\n    def __init__(self, fname, idn=0):\n        super().__init__(fname, idn=idn)\n        # Set variable to hold current action being outputted",
        "detail": "robosuite.models.grippers.gripper_model",
        "documentation": {}
    },
    {
        "label": "GripperTester",
        "kind": 6,
        "importPath": "robosuite.models.grippers.gripper_tester",
        "description": "robosuite.models.grippers.gripper_tester",
        "peekOfCode": "class GripperTester:\n    \"\"\"\n    A class that is used to test gripper\n    Args:\n        gripper (GripperModel): A gripper instance to be tested\n        pos (str): (x y z) position to place the gripper in string form, e.g. '0 0 0.3'\n        quat (str): rotation to apply to gripper in string form, e.g. '0 0 1 0' to flip z axis\n        gripper_low_pos (float): controls the gipper y position, larger -> higher\n        gripper_high_pos (float): controls the gipper y high position larger -> higher,\n            must be larger than gripper_low_pos",
        "detail": "robosuite.models.grippers.gripper_tester",
        "documentation": {}
    },
    {
        "label": "JacoThreeFingerGripperBase",
        "kind": 6,
        "importPath": "robosuite.models.grippers.jaco_three_finger_gripper",
        "description": "robosuite.models.grippers.jaco_three_finger_gripper",
        "peekOfCode": "class JacoThreeFingerGripperBase(GripperModel):\n    \"\"\"\n    Gripper for Kinova's Jaco robot arm (has three fingers).\n    Args:\n        idn (int or str): Number or some other unique identification string for this gripper instance\n    \"\"\"\n    def __init__(self, idn=0):\n        super().__init__(xml_path_completion(\"grippers/jaco_three_finger_gripper.xml\"), idn=idn)\n    def format_action(self, action):\n        return action",
        "detail": "robosuite.models.grippers.jaco_three_finger_gripper",
        "documentation": {}
    },
    {
        "label": "JacoThreeFingerGripper",
        "kind": 6,
        "importPath": "robosuite.models.grippers.jaco_three_finger_gripper",
        "description": "robosuite.models.grippers.jaco_three_finger_gripper",
        "peekOfCode": "class JacoThreeFingerGripper(JacoThreeFingerGripperBase):\n    \"\"\"\n    Modifies JacoThreeFingerGripperBase to only take one action.\n    \"\"\"\n    def format_action(self, action):\n        \"\"\"\n        Maps continuous action into binary output\n        -1 => open, 1 => closed\n        Args:\n            action (np.array): gripper-specific action",
        "detail": "robosuite.models.grippers.jaco_three_finger_gripper",
        "documentation": {}
    },
    {
        "label": "JacoThreeFingerDexterousGripper",
        "kind": 6,
        "importPath": "robosuite.models.grippers.jaco_three_finger_gripper",
        "description": "robosuite.models.grippers.jaco_three_finger_gripper",
        "peekOfCode": "class JacoThreeFingerDexterousGripper(JacoThreeFingerGripperBase):\n    \"\"\"\n    Dexterous variation of the Jaco gripper in which all finger are actuated independently\n    \"\"\"\n    def format_action(self, action):\n        \"\"\"\n        Maps continuous action into binary output\n        all -1 => open, all 1 => closed\n        Args:\n            action (np.array): gripper-specific action",
        "detail": "robosuite.models.grippers.jaco_three_finger_gripper",
        "documentation": {}
    },
    {
        "label": "NullGripper",
        "kind": 6,
        "importPath": "robosuite.models.grippers.null_gripper",
        "description": "robosuite.models.grippers.null_gripper",
        "peekOfCode": "class NullGripper(GripperModel):\n    \"\"\"\n    Dummy Gripper class to represent no gripper\n    Args:\n        idn (int or str): Number or some other unique identification string for this gripper instance\n    \"\"\"\n    def __init__(self, idn=0):\n        super().__init__(xml_path_completion(\"grippers/null_gripper.xml\"), idn=idn)\n    def format_action(self, action):\n        return action",
        "detail": "robosuite.models.grippers.null_gripper",
        "documentation": {}
    },
    {
        "label": "PandaGripperBase",
        "kind": 6,
        "importPath": "robosuite.models.grippers.panda_gripper",
        "description": "robosuite.models.grippers.panda_gripper",
        "peekOfCode": "class PandaGripperBase(GripperModel):\n    \"\"\"\n    Gripper for Franka's Panda (has two fingers).\n    Args:\n        idn (int or str): Number or some other unique identification string for this gripper instance\n    \"\"\"\n    def __init__(self, idn=0):\n        super().__init__(xml_path_completion(\"grippers/panda_gripper.xml\"), idn=idn)\n    def format_action(self, action):\n        return action",
        "detail": "robosuite.models.grippers.panda_gripper",
        "documentation": {}
    },
    {
        "label": "PandaGripper",
        "kind": 6,
        "importPath": "robosuite.models.grippers.panda_gripper",
        "description": "robosuite.models.grippers.panda_gripper",
        "peekOfCode": "class PandaGripper(PandaGripperBase):\n    \"\"\"\n    Modifies PandaGripperBase to only take one action.\n    \"\"\"\n    def format_action(self, action):\n        \"\"\"\n        Maps continuous action into binary output\n        -1 => open, 1 => closed\n        Args:\n            action (np.array): gripper-specific action",
        "detail": "robosuite.models.grippers.panda_gripper",
        "documentation": {}
    },
    {
        "label": "RethinkGripperBase",
        "kind": 6,
        "importPath": "robosuite.models.grippers.rethink_gripper",
        "description": "robosuite.models.grippers.rethink_gripper",
        "peekOfCode": "class RethinkGripperBase(GripperModel):\n    \"\"\"\n    Gripper with long two-fingered parallel jaw.\n    Args:\n        idn (int or str): Number or some other unique identification string for this gripper instance\n    \"\"\"\n    def __init__(self, idn=0):\n        super().__init__(xml_path_completion(\"grippers/rethink_gripper.xml\"), idn=idn)\n    def format_action(self, action):\n        return action",
        "detail": "robosuite.models.grippers.rethink_gripper",
        "documentation": {}
    },
    {
        "label": "RethinkGripper",
        "kind": 6,
        "importPath": "robosuite.models.grippers.rethink_gripper",
        "description": "robosuite.models.grippers.rethink_gripper",
        "peekOfCode": "class RethinkGripper(RethinkGripperBase):\n    \"\"\"\n    Modifies two finger base to only take one action.\n    \"\"\"\n    def format_action(self, action):\n        \"\"\"\n        Maps continuous action into binary output\n        -1 => open, 1 => closed\n        Args:\n            action (np.array): gripper-specific action",
        "detail": "robosuite.models.grippers.rethink_gripper",
        "documentation": {}
    },
    {
        "label": "Robotiq140GripperBase",
        "kind": 6,
        "importPath": "robosuite.models.grippers.robotiq_140_gripper",
        "description": "robosuite.models.grippers.robotiq_140_gripper",
        "peekOfCode": "class Robotiq140GripperBase(GripperModel):\n    \"\"\"\n    Gripper with 140mm Jaw width from Robotiq (has two fingers).\n    Args:\n        idn (int or str): Number or some other unique identification string for this gripper instance\n    \"\"\"\n    def __init__(self, idn=0):\n        super().__init__(xml_path_completion(\"grippers/robotiq_gripper_140.xml\"), idn=idn)\n    def format_action(self, action):\n        return action",
        "detail": "robosuite.models.grippers.robotiq_140_gripper",
        "documentation": {}
    },
    {
        "label": "Robotiq140Gripper",
        "kind": 6,
        "importPath": "robosuite.models.grippers.robotiq_140_gripper",
        "description": "robosuite.models.grippers.robotiq_140_gripper",
        "peekOfCode": "class Robotiq140Gripper(Robotiq140GripperBase):\n    \"\"\"\n    Modifies Robotiq140GripperBase to only take one action.\n    \"\"\"\n    def format_action(self, action):\n        \"\"\"\n        Maps continuous action into binary output\n        -1 => open, 1 => closed\n        Args:\n            action (np.array): gripper-specific action",
        "detail": "robosuite.models.grippers.robotiq_140_gripper",
        "documentation": {}
    },
    {
        "label": "Robotiq85GripperBase",
        "kind": 6,
        "importPath": "robosuite.models.grippers.robotiq_85_gripper",
        "description": "robosuite.models.grippers.robotiq_85_gripper",
        "peekOfCode": "class Robotiq85GripperBase(GripperModel):\n    \"\"\"\n    6-DoF Robotiq gripper.\n    Args:\n        idn (int or str): Number or some other unique identification string for this gripper instance\n    \"\"\"\n    def __init__(self, idn=0):\n        super().__init__(xml_path_completion(\"grippers/robotiq_gripper_85.xml\"), idn=idn)\n    def format_action(self, action):\n        return action",
        "detail": "robosuite.models.grippers.robotiq_85_gripper",
        "documentation": {}
    },
    {
        "label": "Robotiq85Gripper",
        "kind": 6,
        "importPath": "robosuite.models.grippers.robotiq_85_gripper",
        "description": "robosuite.models.grippers.robotiq_85_gripper",
        "peekOfCode": "class Robotiq85Gripper(Robotiq85GripperBase):\n    \"\"\"\n    1-DoF variant of RobotiqGripperBase.\n    \"\"\"\n    def format_action(self, action):\n        \"\"\"\n        Maps continuous action into binary output\n        -1 => open, 1 => closed\n        Args:\n            action (np.array): gripper-specific action",
        "detail": "robosuite.models.grippers.robotiq_85_gripper",
        "documentation": {}
    },
    {
        "label": "RobotiqThreeFingerGripperBase",
        "kind": 6,
        "importPath": "robosuite.models.grippers.robotiq_three_finger_gripper",
        "description": "robosuite.models.grippers.robotiq_three_finger_gripper",
        "peekOfCode": "class RobotiqThreeFingerGripperBase(GripperModel):\n    \"\"\"\n    Gripper with 11 dof controlling three fingers.\n    Args:\n        idn (int or str): Number or some other unique identification string for this gripper instance\n    \"\"\"\n    def __init__(self, idn=0):\n        super().__init__(xml_path_completion(\"grippers/robotiq_gripper_s.xml\"), idn=idn)\n    def format_action(self, action):\n        return action",
        "detail": "robosuite.models.grippers.robotiq_three_finger_gripper",
        "documentation": {}
    },
    {
        "label": "RobotiqThreeFingerGripper",
        "kind": 6,
        "importPath": "robosuite.models.grippers.robotiq_three_finger_gripper",
        "description": "robosuite.models.grippers.robotiq_three_finger_gripper",
        "peekOfCode": "class RobotiqThreeFingerGripper(RobotiqThreeFingerGripperBase):\n    \"\"\"\n    1-DoF variant of RobotiqThreeFingerGripperBase.\n    \"\"\"\n    def format_action(self, action):\n        \"\"\"\n        Maps continuous action into binary output\n        -1 => open, 1 => closed\n        Args:\n            action (np.array): gripper-specific action",
        "detail": "robosuite.models.grippers.robotiq_three_finger_gripper",
        "documentation": {}
    },
    {
        "label": "RobotiqThreeFingerDexterousGripper",
        "kind": 6,
        "importPath": "robosuite.models.grippers.robotiq_three_finger_gripper",
        "description": "robosuite.models.grippers.robotiq_three_finger_gripper",
        "peekOfCode": "class RobotiqThreeFingerDexterousGripper(RobotiqThreeFingerGripperBase):\n    \"\"\"\n    Dexterous variation of the 3-finger Robotiq gripper in which all finger are actuated independently as well\n    as the scissor joint between fingers 1 and 2\n    \"\"\"\n    def format_action(self, action):\n        \"\"\"\n        Maps continuous action into binary output\n        all -1 => open, all 1 => closed\n        Args:",
        "detail": "robosuite.models.grippers.robotiq_three_finger_gripper",
        "documentation": {}
    },
    {
        "label": "WipingGripper",
        "kind": 6,
        "importPath": "robosuite.models.grippers.wiping_gripper",
        "description": "robosuite.models.grippers.wiping_gripper",
        "peekOfCode": "class WipingGripper(GripperModel):\n    \"\"\"\n    A Wiping Gripper with no actuation and enabled with sensors to detect contact forces\n    Args:\n        idn (int or str): Number or some other unique identification string for this gripper instance\n    \"\"\"\n    def __init__(self, idn=0):\n        super().__init__(xml_path_completion('grippers/wiping_gripper.xml'), idn=idn)\n    def format_action(self, action):\n        return action",
        "detail": "robosuite.models.grippers.wiping_gripper",
        "documentation": {}
    },
    {
        "label": "mount_factory",
        "kind": 2,
        "importPath": "robosuite.models.mounts.mount_factory",
        "description": "robosuite.models.mounts.mount_factory",
        "peekOfCode": "def mount_factory(name, idn=0):\n    \"\"\"\n    Generator for grippers\n    Creates a MountModel instance with the provided name.\n    Args:\n        name (None or str): the name of the mount class\n        idn (int or str): Number or some other unique identification string for this mount instance\n    Returns:\n        MountModel: requested mount instance\n    Raises:",
        "detail": "robosuite.models.mounts.mount_factory",
        "documentation": {}
    },
    {
        "label": "MountModel",
        "kind": 6,
        "importPath": "robosuite.models.mounts.mount_model",
        "description": "robosuite.models.mounts.mount_model",
        "peekOfCode": "class MountModel(MujocoXMLModel):\n    \"\"\"\n    Base class for mounts that will be attached to robots. Note that this model's root body will be directly\n    appended to the robot's root body, so all offsets should be taken relative to that.\n    Args:\n        fname (str): Path to relevant xml file to create this mount instance\n        idn (int or str): Number or some other unique identification string for this gripper instance\n    \"\"\"\n    def __init__(self, fname, idn=0):\n        super().__init__(fname, idn=idn)",
        "detail": "robosuite.models.mounts.mount_model",
        "documentation": {}
    },
    {
        "label": "NullMount",
        "kind": 6,
        "importPath": "robosuite.models.mounts.null_mount",
        "description": "robosuite.models.mounts.null_mount",
        "peekOfCode": "class NullMount(MountModel):\n    \"\"\"\n    Dummy Mount to signify no mount.\n    Args:\n        idn (int or str): Number or some other unique identification string for this mount instance\n    \"\"\"\n    def __init__(self, idn=0):\n        super().__init__(xml_path_completion(\"mounts/null_mount.xml\"), idn=idn)\n    @property\n    def top_offset(self):",
        "detail": "robosuite.models.mounts.null_mount",
        "documentation": {}
    },
    {
        "label": "RethinkMinimalMount",
        "kind": 6,
        "importPath": "robosuite.models.mounts.rethink_minimal_mount",
        "description": "robosuite.models.mounts.rethink_minimal_mount",
        "peekOfCode": "class RethinkMinimalMount(MountModel):\n    \"\"\"\n    Mount officially used for Rethink's Baxter Robot. Includes only a wheeled pedestal.\n    Args:\n        idn (int or str): Number or some other unique identification string for this mount instance\n    \"\"\"\n    def __init__(self, idn=0):\n        super().__init__(xml_path_completion(\"mounts/rethink_minimal_mount.xml\"), idn=idn)\n    @property\n    def top_offset(self):",
        "detail": "robosuite.models.mounts.rethink_minimal_mount",
        "documentation": {}
    },
    {
        "label": "RethinkMount",
        "kind": 6,
        "importPath": "robosuite.models.mounts.rethink_mount",
        "description": "robosuite.models.mounts.rethink_mount",
        "peekOfCode": "class RethinkMount(MountModel):\n    \"\"\"\n    Mount officially used for Rethink's Sawyer Robot. Includes a controller box and wheeled pedestal.\n    Args:\n        idn (int or str): Number or some other unique identification string for this mount instance\n    \"\"\"\n    def __init__(self, idn=0):\n        super().__init__(xml_path_completion(\"mounts/rethink_mount.xml\"), idn=idn)\n    @property\n    def top_offset(self):",
        "detail": "robosuite.models.mounts.rethink_mount",
        "documentation": {}
    },
    {
        "label": "HammerObject",
        "kind": 6,
        "importPath": "robosuite.models.objects.composite.hammer",
        "description": "robosuite.models.objects.composite.hammer",
        "peekOfCode": "class HammerObject(CompositeObject):\n    \"\"\"\n    Generates a Hammer object with a cylindrical or box-shaped handle, cubic head, cylindrical face and triangular claw\n    (used in Handover task)\n    Args:\n        name (str): Name of this Hammer object\n        handle_shape (str): Either \"box\", for a box-shaped handle, or \"cylinder\", for a cylindrically-shaped handle\n        handle_radius (float or 2-array of float): Either specific or range of values to draw randomly from\n            uniformly for the handle radius\n        handle_length (float or 2-array of float): Either specific or range of values to draw randomly from",
        "detail": "robosuite.models.objects.composite.hammer",
        "documentation": {}
    },
    {
        "label": "PotWithHandlesObject",
        "kind": 6,
        "importPath": "robosuite.models.objects.composite.pot_with_handles",
        "description": "robosuite.models.objects.composite.pot_with_handles",
        "peekOfCode": "class PotWithHandlesObject(CompositeObject):\n    \"\"\"\n    Generates the Pot object with side handles (used in TwoArmLift)\n    Args:\n        name (str): Name of this Pot object\n        body_half_size (3-array of float): If specified, defines the (x,y,z) half-dimensions of the main pot\n            body. Otherwise, defaults to [0.07, 0.07, 0.07]\n        handle_radius (float): Determines the pot handle radius\n        handle_length (float): Determines the pot handle length\n        handle_width (float): Determines the pot handle width",
        "detail": "robosuite.models.objects.composite.pot_with_handles",
        "documentation": {}
    },
    {
        "label": "HingedBoxObject",
        "kind": 6,
        "importPath": "robosuite.models.objects.composite_body.hinged_box",
        "description": "robosuite.models.objects.composite_body.hinged_box",
        "peekOfCode": "class HingedBoxObject(CompositeBodyObject):\n    \"\"\"\n    An example object that demonstrates the CompositeBodyObject functionality. This object consists of two cube bodies\n    joined together by a hinge joint.\n    Args:\n        name (str): Name of this object\n        box1_size (3-array): (L, W, H) half-sizes for the first box\n        box2_size (3-array): (L, W, H) half-sizes for the second box\n        use_texture (bool): set True if using wood textures for the blocks\n    \"\"\"",
        "detail": "robosuite.models.objects.composite_body.hinged_box",
        "documentation": {}
    },
    {
        "label": "BallObject",
        "kind": 6,
        "importPath": "robosuite.models.objects.primitive.ball",
        "description": "robosuite.models.objects.primitive.ball",
        "peekOfCode": "class BallObject(PrimitiveObject):\n    \"\"\"\n    A ball (sphere) object.\n    Args:\n        size (1-tuple of float): (radius) size parameters for this ball object\n    \"\"\"\n    def __init__(\n        self,\n        name,\n        size=None,",
        "detail": "robosuite.models.objects.primitive.ball",
        "documentation": {}
    },
    {
        "label": "BoxObject",
        "kind": 6,
        "importPath": "robosuite.models.objects.primitive.box",
        "description": "robosuite.models.objects.primitive.box",
        "peekOfCode": "class BoxObject(PrimitiveObject):\n    \"\"\"\n    A box object.\n    Args:\n        size (3-tuple of float): (half-x, half-y, half-z) size parameters for this box object\n    \"\"\"\n    def __init__(\n        self,\n        name,\n        size=None,",
        "detail": "robosuite.models.objects.primitive.box",
        "documentation": {}
    },
    {
        "label": "CapsuleObject",
        "kind": 6,
        "importPath": "robosuite.models.objects.primitive.capsule",
        "description": "robosuite.models.objects.primitive.capsule",
        "peekOfCode": "class CapsuleObject(PrimitiveObject):\n    \"\"\"\n    A capsule object.\n    Args:\n        size (2-tuple of float): (radius, half-length) size parameters for this capsule object\n    \"\"\"\n    def __init__(\n        self,\n        name,\n        size=None,",
        "detail": "robosuite.models.objects.primitive.capsule",
        "documentation": {}
    },
    {
        "label": "CylinderObject",
        "kind": 6,
        "importPath": "robosuite.models.objects.primitive.cylinder",
        "description": "robosuite.models.objects.primitive.cylinder",
        "peekOfCode": "class CylinderObject(PrimitiveObject):\n    \"\"\"\n    A cylinder object.\n    Args:\n        size (2-tuple of float): (radius, half-length) size parameters for this cylinder object\n    \"\"\"\n    def __init__(\n        self,\n        name,\n        size=None,",
        "detail": "robosuite.models.objects.primitive.cylinder",
        "documentation": {}
    },
    {
        "label": "CompositeBodyObject",
        "kind": 6,
        "importPath": "robosuite.models.objects.generated_objects",
        "description": "robosuite.models.objects.generated_objects",
        "peekOfCode": "class CompositeBodyObject(MujocoGeneratedObject):\n    \"\"\"\n    An object constructed out of multiple bodies to make more complex shapes.\n    Args:\n        name (str): Name of overall object\n        objects (MujocoObject or list of MujocoObjects): object(s) to combine to form the composite body object.\n            Note that these objects will be added sequentially, so if an object is required to be nested relative to\n            another object, that nested object should be listed after the parent object. Note that all top-level joints\n            for any inputted objects are automatically stripped\n        object_locations (list): list of body locations in the composite. Each",
        "detail": "robosuite.models.objects.generated_objects",
        "documentation": {}
    },
    {
        "label": "CompositeObject",
        "kind": 6,
        "importPath": "robosuite.models.objects.generated_objects",
        "description": "robosuite.models.objects.generated_objects",
        "peekOfCode": "class CompositeObject(MujocoGeneratedObject):\n    \"\"\"\n    An object constructed out of basic geoms to make more intricate shapes.\n    Note that by default, specifying None for a specific geom element will usually set a value to the mujoco defaults.\n    Args:\n        name (str): Name of overall object\n        total_size (list): (x, y, z) half-size in each dimension for the bounding box for\n            this Composite object\n        geom_types (list): list of geom types in the composite. Must correspond\n            to MuJoCo geom primitives, such as \"box\" or \"capsule\".",
        "detail": "robosuite.models.objects.generated_objects",
        "documentation": {}
    },
    {
        "label": "PrimitiveObject",
        "kind": 6,
        "importPath": "robosuite.models.objects.generated_objects",
        "description": "robosuite.models.objects.generated_objects",
        "peekOfCode": "class PrimitiveObject(MujocoGeneratedObject):\n    \"\"\"\n    Base class for all programmatically generated mujoco object\n    i.e., every MujocoObject that does not have an corresponding xml file\n    Args:\n        name (str): (unique) name to identify this generated object\n        size (n-tuple of float): relevant size parameters for the object, should be of size 1 - 3\n        rgba (4-tuple of float): Color\n        density (float): Density\n        friction (3-tuple of float): (sliding friction, torsional friction, and rolling friction).",
        "detail": "robosuite.models.objects.generated_objects",
        "documentation": {}
    },
    {
        "label": "MujocoObject",
        "kind": 6,
        "importPath": "robosuite.models.objects.objects",
        "description": "robosuite.models.objects.objects",
        "peekOfCode": "class MujocoObject(MujocoModel):\n    \"\"\"\n    Base class for all objects.\n    We use Mujoco Objects to implement all objects that:\n        1) may appear for multiple times in a task\n        2) can be swapped between different tasks\n    Typical methods return copy so the caller can all joints/attributes as wanted\n    Args:\n        obj_type (str): Geom elements to generate / extract for this object. Must be one of:\n            :`'collision'`: Only collision geoms are returned (this corresponds to group 0 geoms)",
        "detail": "robosuite.models.objects.objects",
        "documentation": {}
    },
    {
        "label": "MujocoXMLObject",
        "kind": 6,
        "importPath": "robosuite.models.objects.objects",
        "description": "robosuite.models.objects.objects",
        "peekOfCode": "class MujocoXMLObject(MujocoXML, MujocoObject):\n    \"\"\"\n    MujocoObjects that are loaded from xml files\n    Args:\n        fname (str): XML File path\n        name (str): Name of this MujocoXMLObject\n        joints (None or str or list of dict): each dictionary corresponds to a joint that will be created for this\n            object. The dictionary should specify the joint attributes (type, pos, etc.) according to the MuJoCo xml\n            specification. If \"default\", a single free-joint will be automatically generated. If None, no joints will\n            be created.",
        "detail": "robosuite.models.objects.objects",
        "documentation": {}
    },
    {
        "label": "MujocoGeneratedObject",
        "kind": 6,
        "importPath": "robosuite.models.objects.objects",
        "description": "robosuite.models.objects.objects",
        "peekOfCode": "class MujocoGeneratedObject(MujocoObject):\n    \"\"\"\n    Base class for all procedurally generated objects.\n    Args:\n        obj_type (str): Geom elements to generate / extract for this object. Must be one of:\n            :`'collision'`: Only collision geoms are returned (this corresponds to group 0 geoms)\n            :`'visual'`: Only visual geoms are returned (this corresponds to group 1 geoms)\n            :`'all'`: All geoms are returned\n        duplicate_collision_geoms (bool): If set, will guarantee that each collision geom has a\n            visual geom copy",
        "detail": "robosuite.models.objects.objects",
        "documentation": {}
    },
    {
        "label": "GEOMTYPE2GROUP",
        "kind": 5,
        "importPath": "robosuite.models.objects.objects",
        "description": "robosuite.models.objects.objects",
        "peekOfCode": "GEOMTYPE2GROUP = {\n    \"collision\": {0},                 # If we want to use a geom for physics, but NOT visualize\n    \"visual\": {1},                    # If we want to use a geom for visualization, but NOT physics\n    \"all\": {0, 1},                    # If we want to use a geom for BOTH physics + visualization\n}\nGEOM_GROUPS = GEOMTYPE2GROUP.keys()\nclass MujocoObject(MujocoModel):\n    \"\"\"\n    Base class for all objects.\n    We use Mujoco Objects to implement all objects that:",
        "detail": "robosuite.models.objects.objects",
        "documentation": {}
    },
    {
        "label": "GEOM_GROUPS",
        "kind": 5,
        "importPath": "robosuite.models.objects.objects",
        "description": "robosuite.models.objects.objects",
        "peekOfCode": "GEOM_GROUPS = GEOMTYPE2GROUP.keys()\nclass MujocoObject(MujocoModel):\n    \"\"\"\n    Base class for all objects.\n    We use Mujoco Objects to implement all objects that:\n        1) may appear for multiple times in a task\n        2) can be swapped between different tasks\n    Typical methods return copy so the caller can all joints/attributes as wanted\n    Args:\n        obj_type (str): Geom elements to generate / extract for this object. Must be one of:",
        "detail": "robosuite.models.objects.objects",
        "documentation": {}
    },
    {
        "label": "BottleObject",
        "kind": 6,
        "importPath": "robosuite.models.objects.xml_objects",
        "description": "robosuite.models.objects.xml_objects",
        "peekOfCode": "class BottleObject(MujocoXMLObject):\n    \"\"\"\n    Bottle object\n    \"\"\"\n    def __init__(self, name):\n        super().__init__(xml_path_completion(\"objects/bottle.xml\"),\n                         name=name, joints=[dict(type=\"free\", damping=\"0.0005\")],\n                         obj_type=\"all\", duplicate_collision_geoms=True)\nclass CanObject(MujocoXMLObject):\n    \"\"\"",
        "detail": "robosuite.models.objects.xml_objects",
        "documentation": {}
    },
    {
        "label": "CanObject",
        "kind": 6,
        "importPath": "robosuite.models.objects.xml_objects",
        "description": "robosuite.models.objects.xml_objects",
        "peekOfCode": "class CanObject(MujocoXMLObject):\n    \"\"\"\n    Coke can object (used in PickPlace)\n    \"\"\"\n    def __init__(self, name):\n        super().__init__(xml_path_completion(\"objects/can.xml\"),\n                         name=name, joints=[dict(type=\"free\", damping=\"0.0005\")],\n                         obj_type=\"all\", duplicate_collision_geoms=True)\nclass LemonObject(MujocoXMLObject):\n    \"\"\"",
        "detail": "robosuite.models.objects.xml_objects",
        "documentation": {}
    },
    {
        "label": "LemonObject",
        "kind": 6,
        "importPath": "robosuite.models.objects.xml_objects",
        "description": "robosuite.models.objects.xml_objects",
        "peekOfCode": "class LemonObject(MujocoXMLObject):\n    \"\"\"\n    Lemon object\n    \"\"\"\n    def __init__(self, name):\n        super().__init__(xml_path_completion(\"objects/lemon.xml\"),\n                         name=name, obj_type=\"all\", duplicate_collision_geoms=True)\nclass MilkObject(MujocoXMLObject):\n    \"\"\"\n    Milk carton object (used in PickPlace)",
        "detail": "robosuite.models.objects.xml_objects",
        "documentation": {}
    },
    {
        "label": "MilkObject",
        "kind": 6,
        "importPath": "robosuite.models.objects.xml_objects",
        "description": "robosuite.models.objects.xml_objects",
        "peekOfCode": "class MilkObject(MujocoXMLObject):\n    \"\"\"\n    Milk carton object (used in PickPlace)\n    \"\"\"\n    def __init__(self, name):\n        super().__init__(xml_path_completion(\"objects/milk.xml\"),\n                         name=name, joints=[dict(type=\"free\", damping=\"0.0005\")],\n                         obj_type=\"all\", duplicate_collision_geoms=True)\nclass BreadObject(MujocoXMLObject):\n    \"\"\"",
        "detail": "robosuite.models.objects.xml_objects",
        "documentation": {}
    },
    {
        "label": "BreadObject",
        "kind": 6,
        "importPath": "robosuite.models.objects.xml_objects",
        "description": "robosuite.models.objects.xml_objects",
        "peekOfCode": "class BreadObject(MujocoXMLObject):\n    \"\"\"\n    Bread loaf object (used in PickPlace)\n    \"\"\"\n    def __init__(self, name):\n        super().__init__(xml_path_completion(\"objects/bread.xml\"),\n                         name=name, joints=[dict(type=\"free\", damping=\"0.0005\")],\n                         obj_type=\"all\", duplicate_collision_geoms=True)\nclass CerealObject(MujocoXMLObject):\n    \"\"\"",
        "detail": "robosuite.models.objects.xml_objects",
        "documentation": {}
    },
    {
        "label": "CerealObject",
        "kind": 6,
        "importPath": "robosuite.models.objects.xml_objects",
        "description": "robosuite.models.objects.xml_objects",
        "peekOfCode": "class CerealObject(MujocoXMLObject):\n    \"\"\"\n    Cereal box object (used in PickPlace)\n    \"\"\"\n    def __init__(self, name):\n        super().__init__(xml_path_completion(\"objects/cereal.xml\"),\n                         name=name, joints=[dict(type=\"free\", damping=\"0.0005\")],\n                         obj_type=\"all\", duplicate_collision_geoms=True)\nclass PegObject(MujocoXMLObject):\n    def __init__(self, name):",
        "detail": "robosuite.models.objects.xml_objects",
        "documentation": {}
    },
    {
        "label": "PegObject",
        "kind": 6,
        "importPath": "robosuite.models.objects.xml_objects",
        "description": "robosuite.models.objects.xml_objects",
        "peekOfCode": "class PegObject(MujocoXMLObject):\n    def __init__(self, name):\n        super().__init__(xml_path_completion(\"objects/peg.xml\"),\n                         name=name, joints=[dict(type=\"free\", damping=\"0.0005\")],\n                         obj_type=\"all\", duplicate_collision_geoms=True)\n    @property\n    def important_sites(self):\n        # Get dict from super call and add to it\n        dic = super().important_sites\n        dic.update({",
        "detail": "robosuite.models.objects.xml_objects",
        "documentation": {}
    },
    {
        "label": "SquareNutObject",
        "kind": 6,
        "importPath": "robosuite.models.objects.xml_objects",
        "description": "robosuite.models.objects.xml_objects",
        "peekOfCode": "class SquareNutObject(MujocoXMLObject):\n    \"\"\"\n    Square nut object (used in NutAssembly)\n    \"\"\"\n    def __init__(self, name):\n        super().__init__(xml_path_completion(\"objects/square-nut.xml\"),\n                         name=name, joints=[dict(type=\"free\", damping=\"0.0005\")],\n                         obj_type=\"all\", duplicate_collision_geoms=True)\n    @property\n    def important_sites(self):",
        "detail": "robosuite.models.objects.xml_objects",
        "documentation": {}
    },
    {
        "label": "RoundNutObject",
        "kind": 6,
        "importPath": "robosuite.models.objects.xml_objects",
        "description": "robosuite.models.objects.xml_objects",
        "peekOfCode": "class RoundNutObject(MujocoXMLObject):\n    \"\"\"\n    Round nut (used in NutAssembly)\n    \"\"\"\n    def __init__(self, name):\n        super().__init__(xml_path_completion(\"objects/round-nut.xml\"),\n                         name=name, joints=[dict(type=\"free\", damping=\"0.0005\")],\n                         obj_type=\"all\", duplicate_collision_geoms=True)\n    @property\n    def important_sites(self):",
        "detail": "robosuite.models.objects.xml_objects",
        "documentation": {}
    },
    {
        "label": "MilkVisualObject",
        "kind": 6,
        "importPath": "robosuite.models.objects.xml_objects",
        "description": "robosuite.models.objects.xml_objects",
        "peekOfCode": "class MilkVisualObject(MujocoXMLObject):\n    \"\"\"\n    Visual fiducial of milk carton (used in PickPlace).\n    Fiducial objects are not involved in collision physics.\n    They provide a point of reference to indicate a position.\n    \"\"\"\n    def __init__(self, name):\n        super().__init__(xml_path_completion(\"objects/milk-visual.xml\"),\n                         name=name, joints=None, obj_type=\"visual\", duplicate_collision_geoms=True)\nclass BreadVisualObject(MujocoXMLObject):",
        "detail": "robosuite.models.objects.xml_objects",
        "documentation": {}
    },
    {
        "label": "BreadVisualObject",
        "kind": 6,
        "importPath": "robosuite.models.objects.xml_objects",
        "description": "robosuite.models.objects.xml_objects",
        "peekOfCode": "class BreadVisualObject(MujocoXMLObject):\n    \"\"\"\n    Visual fiducial of bread loaf (used in PickPlace)\n    Fiducial objects are not involved in collision physics.\n    They provide a point of reference to indicate a position.\n    \"\"\"\n    def __init__(self, name):\n        super().__init__(xml_path_completion(\"objects/bread-visual.xml\"),\n                         name=name, joints=None, obj_type=\"visual\", duplicate_collision_geoms=True)\nclass CerealVisualObject(MujocoXMLObject):",
        "detail": "robosuite.models.objects.xml_objects",
        "documentation": {}
    },
    {
        "label": "CerealVisualObject",
        "kind": 6,
        "importPath": "robosuite.models.objects.xml_objects",
        "description": "robosuite.models.objects.xml_objects",
        "peekOfCode": "class CerealVisualObject(MujocoXMLObject):\n    \"\"\"\n    Visual fiducial of cereal box (used in PickPlace)\n    Fiducial objects are not involved in collision physics.\n    They provide a point of reference to indicate a position.\n    \"\"\"\n    def __init__(self, name):\n        super().__init__(xml_path_completion(\"objects/cereal-visual.xml\"),\n                         name=name, joints=None, obj_type=\"visual\", duplicate_collision_geoms=True)\nclass CanVisualObject(MujocoXMLObject):",
        "detail": "robosuite.models.objects.xml_objects",
        "documentation": {}
    },
    {
        "label": "CanVisualObject",
        "kind": 6,
        "importPath": "robosuite.models.objects.xml_objects",
        "description": "robosuite.models.objects.xml_objects",
        "peekOfCode": "class CanVisualObject(MujocoXMLObject):\n    \"\"\"\n    Visual fiducial of coke can (used in PickPlace)\n    Fiducial objects are not involved in collision physics.\n    They provide a point of reference to indicate a position.\n    \"\"\"\n    def __init__(self, name):\n        super().__init__(xml_path_completion(\"objects/can-visual.xml\"),\n                         name=name, joints=None, obj_type=\"visual\", duplicate_collision_geoms=True)\nclass PlateWithHoleObject(MujocoXMLObject):",
        "detail": "robosuite.models.objects.xml_objects",
        "documentation": {}
    },
    {
        "label": "PlateWithHoleObject",
        "kind": 6,
        "importPath": "robosuite.models.objects.xml_objects",
        "description": "robosuite.models.objects.xml_objects",
        "peekOfCode": "class PlateWithHoleObject(MujocoXMLObject):\n    \"\"\"\n    Square plate with a hole in the center (used in PegInHole)\n    \"\"\"\n    def __init__(self, name):\n        super().__init__(xml_path_completion(\"objects/plate-with-hole.xml\"),\n                         name=name, joints=None, obj_type=\"all\", duplicate_collision_geoms=True)\nclass DoorObject(MujocoXMLObject):\n    \"\"\"\n    Door with handle (used in Door)",
        "detail": "robosuite.models.objects.xml_objects",
        "documentation": {}
    },
    {
        "label": "DoorObject",
        "kind": 6,
        "importPath": "robosuite.models.objects.xml_objects",
        "description": "robosuite.models.objects.xml_objects",
        "peekOfCode": "class DoorObject(MujocoXMLObject):\n    \"\"\"\n    Door with handle (used in Door)\n    Args:\n        friction (3-tuple of float): friction parameters to override the ones specified in the XML\n        damping (float): damping parameter to override the ones specified in the XML\n        lock (bool): Whether to use the locked door variation object or not\n    \"\"\"\n    def __init__(self, name, friction=None, damping=None, lock=False):\n        xml_path = \"objects/door.xml\"",
        "detail": "robosuite.models.objects.xml_objects",
        "documentation": {}
    },
    {
        "label": "Baxter",
        "kind": 6,
        "importPath": "robosuite.models.robots.manipulators.baxter_robot",
        "description": "robosuite.models.robots.manipulators.baxter_robot",
        "peekOfCode": "class Baxter(ManipulatorModel):\n    \"\"\"\n    Baxter is a hunky bimanual robot designed by Rethink Robotics.\n    Args:\n        idn (int or str): Number or some other unique identification string for this robot instance\n    \"\"\"\n    def __init__(self, idn=0):\n        super().__init__(xml_path_completion(\"robots/baxter/robot.xml\"), idn=idn)\n    @property\n    def default_mount(self):",
        "detail": "robosuite.models.robots.manipulators.baxter_robot",
        "documentation": {}
    },
    {
        "label": "IIWA",
        "kind": 6,
        "importPath": "robosuite.models.robots.manipulators.iiwa_robot",
        "description": "robosuite.models.robots.manipulators.iiwa_robot",
        "peekOfCode": "class IIWA(ManipulatorModel):\n    \"\"\"\n    IIWA is a bright and spunky robot created by KUKA\n    Args:\n        idn (int or str): Number or some other unique identification string for this robot instance\n    \"\"\"\n    def __init__(self, idn=0):\n        super().__init__(xml_path_completion(\"robots/iiwa/robot.xml\"), idn=idn)\n    @property\n    def default_mount(self):",
        "detail": "robosuite.models.robots.manipulators.iiwa_robot",
        "documentation": {}
    },
    {
        "label": "Jaco",
        "kind": 6,
        "importPath": "robosuite.models.robots.manipulators.jaco_robot",
        "description": "robosuite.models.robots.manipulators.jaco_robot",
        "peekOfCode": "class Jaco(ManipulatorModel):\n    \"\"\"\n    Jaco is a kind and assistive robot created by Kinova\n    Args:\n        idn (int or str): Number or some other unique identification string for this robot instance\n    \"\"\"\n    def __init__(self, idn=0):\n        super().__init__(xml_path_completion(\"robots/jaco/robot.xml\"), idn=idn)\n    @property\n    def default_mount(self):",
        "detail": "robosuite.models.robots.manipulators.jaco_robot",
        "documentation": {}
    },
    {
        "label": "Kinova3",
        "kind": 6,
        "importPath": "robosuite.models.robots.manipulators.kinova3_robot",
        "description": "robosuite.models.robots.manipulators.kinova3_robot",
        "peekOfCode": "class Kinova3(ManipulatorModel):\n    \"\"\"\n    The Gen3 robot is the sparkly newest addition to the Kinova line\n    Args:\n        idn (int or str): Number or some other unique identification string for this robot instance\n    \"\"\"\n    def __init__(self, idn=0):\n        super().__init__(xml_path_completion(\"robots/kinova3/robot.xml\"), idn=idn)\n    @property\n    def default_mount(self):",
        "detail": "robosuite.models.robots.manipulators.kinova3_robot",
        "documentation": {}
    },
    {
        "label": "ManipulatorModel",
        "kind": 6,
        "importPath": "robosuite.models.robots.manipulators.manipulator_model",
        "description": "robosuite.models.robots.manipulators.manipulator_model",
        "peekOfCode": "class ManipulatorModel(RobotModel):\n    \"\"\"\n    Base class for all manipulator models (robot arm(s) with gripper(s)).\n    Args:\n        fname (str): Path to relevant xml file from which to create this robot instance\n        idn (int or str): Number or some other unique identification string for this robot instance\n    \"\"\"\n    def __init__(self, fname, idn=0):\n        # Always run super init first\n        super().__init__(fname, idn=idn)",
        "detail": "robosuite.models.robots.manipulators.manipulator_model",
        "documentation": {}
    },
    {
        "label": "Panda",
        "kind": 6,
        "importPath": "robosuite.models.robots.manipulators.panda_robot",
        "description": "robosuite.models.robots.manipulators.panda_robot",
        "peekOfCode": "class Panda(ManipulatorModel):\n    \"\"\"\n    Panda is a sensitive single-arm robot designed by Franka.\n    Args:\n        idn (int or str): Number or some other unique identification string for this robot instance\n    \"\"\"\n    def __init__(self, idn=0):\n        super().__init__(xml_path_completion(\"robots/panda/robot.xml\"), idn=idn)\n        # Set joint damping\n        self.set_joint_attribute(attrib=\"damping\", values=np.array((0.1, 0.1, 0.1, 0.1, 0.1, 0.01, 0.01)))",
        "detail": "robosuite.models.robots.manipulators.panda_robot",
        "documentation": {}
    },
    {
        "label": "Sawyer",
        "kind": 6,
        "importPath": "robosuite.models.robots.manipulators.sawyer_robot",
        "description": "robosuite.models.robots.manipulators.sawyer_robot",
        "peekOfCode": "class Sawyer(ManipulatorModel):\n    \"\"\"\n    Sawyer is a witty single-arm robot designed by Rethink Robotics.\n    Args:\n        idn (int or str): Number or some other unique identification string for this robot instance\n    \"\"\"\n    def __init__(self, idn=0):\n        super().__init__(xml_path_completion(\"robots/sawyer/robot.xml\"), idn=idn)\n    @property\n    def default_mount(self):",
        "detail": "robosuite.models.robots.manipulators.sawyer_robot",
        "documentation": {}
    },
    {
        "label": "UR5e",
        "kind": 6,
        "importPath": "robosuite.models.robots.manipulators.ur5e_robot",
        "description": "robosuite.models.robots.manipulators.ur5e_robot",
        "peekOfCode": "class UR5e(ManipulatorModel):\n    \"\"\"\n    UR5e is a sleek and elegant new robot created by Universal Robots\n    Args:\n        idn (int or str): Number or some other unique identification string for this robot instance\n    \"\"\"\n    def __init__(self, idn=0):\n        super().__init__(xml_path_completion(\"robots/ur5e/robot.xml\"), idn=idn)\n    @property\n    def default_mount(self):",
        "detail": "robosuite.models.robots.manipulators.ur5e_robot",
        "documentation": {}
    },
    {
        "label": "RobotModelMeta",
        "kind": 6,
        "importPath": "robosuite.models.robots.robot_model",
        "description": "robosuite.models.robots.robot_model",
        "peekOfCode": "class RobotModelMeta(type):\n    \"\"\"Metaclass for registering robot arms\"\"\"\n    def __new__(meta, name, bases, class_dict):\n        cls = super().__new__(meta, name, bases, class_dict)\n        # List all environments that should not be registered here.\n        _unregistered_envs = [\"RobotModel\", \"ManipulatorModel\"]\n        if cls.__name__ not in _unregistered_envs:\n            register_robot(cls)\n        return cls\nclass RobotModel(MujocoXMLModel, metaclass=RobotModelMeta):",
        "detail": "robosuite.models.robots.robot_model",
        "documentation": {}
    },
    {
        "label": "RobotModel",
        "kind": 6,
        "importPath": "robosuite.models.robots.robot_model",
        "description": "robosuite.models.robots.robot_model",
        "peekOfCode": "class RobotModel(MujocoXMLModel, metaclass=RobotModelMeta):\n    \"\"\"\n    Base class for all robot models.\n    Args:\n        fname (str): Path to relevant xml file from which to create this robot instance\n        idn (int or str): Number or some other unique identification string for this robot instance\n    \"\"\"\n    def __init__(self, fname, idn=0):\n        super().__init__(fname, idn=idn)\n        # Define other variables that get filled later",
        "detail": "robosuite.models.robots.robot_model",
        "documentation": {}
    },
    {
        "label": "register_robot",
        "kind": 2,
        "importPath": "robosuite.models.robots.robot_model",
        "description": "robosuite.models.robots.robot_model",
        "peekOfCode": "def register_robot(target_class):\n    REGISTERED_ROBOTS[target_class.__name__] = target_class\ndef create_robot(robot_name, *args, **kwargs):\n    \"\"\"\n    Instantiates a Robot object.\n    Args:\n        robot_name (str): Name of the robot to initialize\n        *args: Additional arguments to pass to the specific Robot class initializer\n        **kwargs: Additional arguments to pass to the specific Robot class initializer\n    Returns:",
        "detail": "robosuite.models.robots.robot_model",
        "documentation": {}
    },
    {
        "label": "create_robot",
        "kind": 2,
        "importPath": "robosuite.models.robots.robot_model",
        "description": "robosuite.models.robots.robot_model",
        "peekOfCode": "def create_robot(robot_name, *args, **kwargs):\n    \"\"\"\n    Instantiates a Robot object.\n    Args:\n        robot_name (str): Name of the robot to initialize\n        *args: Additional arguments to pass to the specific Robot class initializer\n        **kwargs: Additional arguments to pass to the specific Robot class initializer\n    Returns:\n        Robot: Desired robot\n    Raises:",
        "detail": "robosuite.models.robots.robot_model",
        "documentation": {}
    },
    {
        "label": "REGISTERED_ROBOTS",
        "kind": 5,
        "importPath": "robosuite.models.robots.robot_model",
        "description": "robosuite.models.robots.robot_model",
        "peekOfCode": "REGISTERED_ROBOTS = {}\ndef register_robot(target_class):\n    REGISTERED_ROBOTS[target_class.__name__] = target_class\ndef create_robot(robot_name, *args, **kwargs):\n    \"\"\"\n    Instantiates a Robot object.\n    Args:\n        robot_name (str): Name of the robot to initialize\n        *args: Additional arguments to pass to the specific Robot class initializer\n        **kwargs: Additional arguments to pass to the specific Robot class initializer",
        "detail": "robosuite.models.robots.robot_model",
        "documentation": {}
    },
    {
        "label": "ManipulationTask",
        "kind": 6,
        "importPath": "robosuite.models.tasks.manipulation_task",
        "description": "robosuite.models.tasks.manipulation_task",
        "peekOfCode": "class ManipulationTask(Task):\n    \"\"\"\n    A manipulation-specific task. This is currently a future-proofing placeholder.\n    \"\"\"",
        "detail": "robosuite.models.tasks.manipulation_task",
        "documentation": {}
    },
    {
        "label": "Task",
        "kind": 6,
        "importPath": "robosuite.models.tasks.task",
        "description": "robosuite.models.tasks.task",
        "peekOfCode": "class Task(MujocoWorldBase):\n    \"\"\"\n    Creates MJCF model for a task performed.\n    A task consists of one or more robots interacting with a variable number of\n    objects. This class combines the robot(s), the arena, and the objects\n    into a single MJCF model.\n    Args:\n        mujoco_arena (Arena): MJCF model of robot workspace\n        mujoco_robots (RobotModel or list of RobotModel): MJCF model of robot model(s) (list)\n        mujoco_objects (None or MujocoObject or list of MujocoObject): a list of MJCF models of physical objects",
        "detail": "robosuite.models.tasks.task",
        "documentation": {}
    },
    {
        "label": "MujocoXML",
        "kind": 6,
        "importPath": "robosuite.models.base",
        "description": "robosuite.models.base",
        "peekOfCode": "class MujocoXML(object):\n    \"\"\"\n    Base class of Mujoco xml file\n    Wraps around ElementTree and provides additional functionality for merging different models.\n    Specially, we keep track of <worldbody/>, <actuator/> and <asset/>\n    When initialized, loads a mujoco xml from file.\n    Args:\n        fname (str): path to the MJCF xml file.\n    \"\"\"\n    def __init__(self, fname):",
        "detail": "robosuite.models.base",
        "documentation": {}
    },
    {
        "label": "MujocoModel",
        "kind": 6,
        "importPath": "robosuite.models.base",
        "description": "robosuite.models.base",
        "peekOfCode": "class MujocoModel(object):\n    \"\"\"\n    Base class for all simulation models used in mujoco.\n    Standardizes core API for accessing models' relevant geoms, names, etc.\n    \"\"\"\n    def correct_naming(self, names):\n        \"\"\"\n        Corrects all strings in @names by adding the naming prefix to it and returns the name-corrected values\n        Args:\n            names (str, list, or dict): Name(s) to be corrected",
        "detail": "robosuite.models.base",
        "documentation": {}
    },
    {
        "label": "MujocoXMLModel",
        "kind": 6,
        "importPath": "robosuite.models.base",
        "description": "robosuite.models.base",
        "peekOfCode": "class MujocoXMLModel(MujocoXML, MujocoModel):\n    \"\"\"\n    Base class for all MujocoModels that are based on a raw XML file.\n    Args:\n        fname (str): Path to relevant xml file from which to create this robot instance\n        idn (int or str): Number or some other unique identification string for this model instance\n    \"\"\"\n    def __init__(self, fname, idn=0):\n        super().__init__(fname)\n        # Set id and add prefixes to all body names to prevent naming clashes",
        "detail": "robosuite.models.base",
        "documentation": {}
    },
    {
        "label": "MujocoWorldBase",
        "kind": 6,
        "importPath": "robosuite.models.world",
        "description": "robosuite.models.world",
        "peekOfCode": "class MujocoWorldBase(MujocoXML):\n    \"\"\"Base class to inherit all mujoco worlds from.\"\"\"\n    def __init__(self):\n        super().__init__(xml_path_completion(\"base.xml\"))",
        "detail": "robosuite.models.world",
        "documentation": {}
    },
    {
        "label": "Bimanual",
        "kind": 6,
        "importPath": "robosuite.robots.bimanual",
        "description": "robosuite.robots.bimanual",
        "peekOfCode": "class Bimanual(Manipulator):\n    \"\"\"\n    Initializes a bimanual robot simulation object.\n    Args:\n        robot_type (str): Specification for specific robot arm to be instantiated within this env (e.g: \"Panda\")\n        idn (int or str): Unique ID of this robot. Should be different from others\n        controller_config (dict or list of dict --> dict of dict): If set, contains relevant controller parameters\n            for creating custom controllers. Else, uses the default controller for this specific task. Should either\n            be single dict if same controller is to be used for both robot arms or else it should be a list of length 2.\n            :NOTE: In the latter case, assumes convention of [right, left]",
        "detail": "robosuite.robots.bimanual",
        "documentation": {}
    },
    {
        "label": "Manipulator",
        "kind": 6,
        "importPath": "robosuite.robots.manipulator",
        "description": "robosuite.robots.manipulator",
        "peekOfCode": "class Manipulator(Robot):\n    \"\"\"\n    Initializes a manipulator robot simulation object, as defined by a single corresponding robot arm XML and\n    associated gripper XML\n    \"\"\"\n    def _load_controller(self):\n        raise NotImplementedError\n    def control(self, action, policy_step=False):\n        raise NotImplementedError\n    def grip_action(self, gripper, gripper_action):",
        "detail": "robosuite.robots.manipulator",
        "documentation": {}
    },
    {
        "label": "Robot",
        "kind": 6,
        "importPath": "robosuite.robots.robot",
        "description": "robosuite.robots.robot",
        "peekOfCode": "class Robot(object):\n    \"\"\"\n    Initializes a robot simulation object, as defined by a single corresponding robot XML\n    Args:\n        robot_type (str): Specification for specific robot arm to be instantiated within this env (e.g: \"Panda\")\n        idn (int or str): Unique ID of this robot. Should be different from others\n        initial_qpos (sequence of float): If set, determines the initial joint positions of the robot to be\n            instantiated for the task\n        initialization_noise (dict): Dict containing the initialization noise parameters. The expected keys and\n            corresponding value types are specified below:",
        "detail": "robosuite.robots.robot",
        "documentation": {}
    },
    {
        "label": "SingleArm",
        "kind": 6,
        "importPath": "robosuite.robots.single_arm",
        "description": "robosuite.robots.single_arm",
        "peekOfCode": "class SingleArm(Manipulator):\n    \"\"\"\n    Initializes a single-armed robot simulation object.\n    Args:\n        robot_type (str): Specification for specific robot arm to be instantiated within this env (e.g: \"Panda\")\n        idn (int or str): Unique ID of this robot. Should be different from others\n        controller_config (dict): If set, contains relevant controller parameters for creating a custom controller.\n            Else, uses the default controller for this specific task\n        initial_qpos (sequence of float): If set, determines the initial joint positions of the robot to be\n            instantiated for the task",
        "detail": "robosuite.robots.single_arm",
        "documentation": {}
    },
    {
        "label": "collect_human_trajectory",
        "kind": 2,
        "importPath": "robosuite.scripts.collect_human_demonstrations",
        "description": "robosuite.scripts.collect_human_demonstrations",
        "peekOfCode": "def collect_human_trajectory(env, device, arm, env_configuration):\n    \"\"\"\n    Use the device (keyboard or SpaceNav 3D mouse) to collect a demonstration.\n    The rollout trajectory is saved to files in npz format.\n    Modify the DataCollectionWrapper wrapper to add new fields or change data formats.\n    Args:\n        env (MujocoEnv): environment to control\n        device (Device): to receive controls from the device\n        arms (str): which arm to control (eg bimanual) 'right' or 'left'\n        env_configuration (str): specified environment configuration",
        "detail": "robosuite.scripts.collect_human_demonstrations",
        "documentation": {}
    },
    {
        "label": "gather_demonstrations_as_hdf5",
        "kind": 2,
        "importPath": "robosuite.scripts.collect_human_demonstrations",
        "description": "robosuite.scripts.collect_human_demonstrations",
        "peekOfCode": "def gather_demonstrations_as_hdf5(directory, out_dir, env_info):\n    \"\"\"\n    Gathers the demonstrations saved in @directory into a\n    single hdf5 file.\n    The strucure of the hdf5 file is as follows.\n    data (group)\n        date (attribute) - date of collection\n        time (attribute) - time of collection\n        repository_version (attribute) - repository version used during collection\n        env (attribute) - environment name on which demos were collected",
        "detail": "robosuite.scripts.collect_human_demonstrations",
        "documentation": {}
    },
    {
        "label": "print_usage",
        "kind": 2,
        "importPath": "robosuite.scripts.compile_mjcf_model",
        "description": "robosuite.scripts.compile_mjcf_model",
        "peekOfCode": "def print_usage():\n    print(\"\"\"python compile_mjcf_model.py input_file output_file\"\"\")\nif __name__ == \"__main__\":\n    if len(sys.argv) != 3:\n        print_usage()\n        exit(0)\n    input_file = sys.argv[1]\n    output_file = sys.argv[2]\n    input_folder = os.path.dirname(input_file)\n    tempfile = os.path.join(input_folder, \".robosuite_temp_model.xml\")",
        "detail": "robosuite.scripts.compile_mjcf_model",
        "documentation": {}
    },
    {
        "label": "KeyboardHandler",
        "kind": 6,
        "importPath": "robosuite.scripts.tune_camera",
        "description": "robosuite.scripts.tune_camera",
        "peekOfCode": "class KeyboardHandler:\n    def __init__(self, env, camera_id):\n        \"\"\"\n        Store internal state here.\n        Args:\n            env (MujocoEnv): Environment to use\n            camera_id (int): which camera to modify\n        \"\"\"\n        self.env = env\n        self.camera_id = camera_id",
        "detail": "robosuite.scripts.tune_camera",
        "documentation": {}
    },
    {
        "label": "modify_xml_for_camera_movement",
        "kind": 2,
        "importPath": "robosuite.scripts.tune_camera",
        "description": "robosuite.scripts.tune_camera",
        "peekOfCode": "def modify_xml_for_camera_movement(xml, camera_name):\n    \"\"\"\n    Cameras in mujoco are 'fixed', so they can't be moved by default.\n    Although it's possible to hack position movement, rotation movement\n    does not work. An alternative is to attach a camera to a mocap body,\n    and move the mocap body.\n    This function modifies the camera with name @camera_name in the xml\n    by attaching it to a mocap body that can move around freely. In this\n    way, we can move the camera by moving the mocap body.\n    See http://www.mujoco.org/forum/index.php?threads/move-camera.2201/ for",
        "detail": "robosuite.scripts.tune_camera",
        "documentation": {}
    },
    {
        "label": "move_camera",
        "kind": 2,
        "importPath": "robosuite.scripts.tune_camera",
        "description": "robosuite.scripts.tune_camera",
        "peekOfCode": "def move_camera(env, direction, scale, camera_id):\n    \"\"\"\n    Move the camera view along a direction (in the camera frame).\n    Args:\n        direction (np.arry): 3-array for where to move camera in camera frame\n        scale (float): how much to move along that direction\n        camera_id (int): which camera to modify\n    \"\"\"\n    # current camera pose\n    camera_pos = np.array(env.sim.data.get_mocap_pos(\"cameramover\"))",
        "detail": "robosuite.scripts.tune_camera",
        "documentation": {}
    },
    {
        "label": "rotate_camera",
        "kind": 2,
        "importPath": "robosuite.scripts.tune_camera",
        "description": "robosuite.scripts.tune_camera",
        "peekOfCode": "def rotate_camera(env, direction, angle, camera_id):\n    \"\"\"\n    Rotate the camera view about a direction (in the camera frame).\n    Args:\n        direction (np.array): 3-array for where to move camera in camera frame\n        angle (float): how much to rotate about that direction\n        camera_id (int): which camera to modify\n    \"\"\"\n    # current camera rotation\n    camera_rot = T.quat2mat(T.convert_quat(env.sim.data.get_mocap_quat(\"cameramover\"), to='xyzw'))",
        "detail": "robosuite.scripts.tune_camera",
        "documentation": {}
    },
    {
        "label": "print_command",
        "kind": 2,
        "importPath": "robosuite.scripts.tune_camera",
        "description": "robosuite.scripts.tune_camera",
        "peekOfCode": "def print_command(char, info):\n    \"\"\"\n    Prints out the command + relevant info entered by user\n    Args:\n        char (str): Command entered\n        info (str): Any additional info to print\n    \"\"\"\n    char += \" \" * (10 - len(char))\n    print(\"{}\\t{}\".format(char, info))\nif __name__ == \"__main__\":",
        "detail": "robosuite.scripts.tune_camera",
        "documentation": {}
    },
    {
        "label": "DELTA_POS_KEY_PRESS",
        "kind": 5,
        "importPath": "robosuite.scripts.tune_camera",
        "description": "robosuite.scripts.tune_camera",
        "peekOfCode": "DELTA_POS_KEY_PRESS = 0.05      # delta camera position per key press\nDELTA_ROT_KEY_PRESS = 1         # delta camera angle per key press\ndef modify_xml_for_camera_movement(xml, camera_name):\n    \"\"\"\n    Cameras in mujoco are 'fixed', so they can't be moved by default.\n    Although it's possible to hack position movement, rotation movement\n    does not work. An alternative is to attach a camera to a mocap body,\n    and move the mocap body.\n    This function modifies the camera with name @camera_name in the xml\n    by attaching it to a mocap body that can move around freely. In this",
        "detail": "robosuite.scripts.tune_camera",
        "documentation": {}
    },
    {
        "label": "DELTA_ROT_KEY_PRESS",
        "kind": 5,
        "importPath": "robosuite.scripts.tune_camera",
        "description": "robosuite.scripts.tune_camera",
        "peekOfCode": "DELTA_ROT_KEY_PRESS = 1         # delta camera angle per key press\ndef modify_xml_for_camera_movement(xml, camera_name):\n    \"\"\"\n    Cameras in mujoco are 'fixed', so they can't be moved by default.\n    Although it's possible to hack position movement, rotation movement\n    does not work. An alternative is to attach a camera to a mocap body,\n    and move the mocap body.\n    This function modifies the camera with name @camera_name in the xml\n    by attaching it to a mocap body that can move around freely. In this\n    way, we can move the camera by moving the mocap body.",
        "detail": "robosuite.scripts.tune_camera",
        "documentation": {}
    },
    {
        "label": "KeyboardHandler",
        "kind": 6,
        "importPath": "robosuite.scripts.tune_joints",
        "description": "robosuite.scripts.tune_joints",
        "peekOfCode": "class KeyboardHandler:\n    def __init__(self, env, delta=0.05):\n        \"\"\"\n        Store internal state here.\n        Args:\n            env (MujocoEnv): Environment to use\n            delta (float): initial joint tuning increment\n        \"\"\"\n        self.env = env\n        self.delta = delta",
        "detail": "robosuite.scripts.tune_joints",
        "documentation": {}
    },
    {
        "label": "print_command",
        "kind": 2,
        "importPath": "robosuite.scripts.tune_joints",
        "description": "robosuite.scripts.tune_joints",
        "peekOfCode": "def print_command(char, info):\n    \"\"\"\n    Prints out the command + relevant info entered by user\n    Args:\n        char (str): Command entered\n        info (str): Any additional info to print\n    \"\"\"\n    char += \" \" * (10 - len(char))\n    print(\"{}\\t{}\".format(char, info))\nif __name__ == \"__main__\":",
        "detail": "robosuite.scripts.tune_joints",
        "documentation": {}
    },
    {
        "label": "Buffer",
        "kind": 6,
        "importPath": "robosuite.utils.control_utils",
        "description": "robosuite.utils.control_utils",
        "peekOfCode": "class Buffer(object):\n    \"\"\"\n    Abstract class for different kinds of data buffers. Minimum API should have a \"push\" and \"clear\" method\n    \"\"\"\n    def push(self, value):\n        \"\"\"\n        Pushes a new @value to the buffer\n        Args:\n            value: Value to push to the buffer\n        \"\"\"",
        "detail": "robosuite.utils.control_utils",
        "documentation": {}
    },
    {
        "label": "RingBuffer",
        "kind": 6,
        "importPath": "robosuite.utils.control_utils",
        "description": "robosuite.utils.control_utils",
        "peekOfCode": "class RingBuffer(Buffer):\n    \"\"\"\n    Simple RingBuffer object to hold values to average (useful for, e.g.: filtering D component in PID control)\n    Note that the buffer object is a 2D numpy array, where each row corresponds to\n    individual entries into the buffer\n    Args:\n        dim (int): Size of entries being added. This is, e.g.: the size of a state vector that is to be stored\n        length (int): Size of the ring buffer\n    \"\"\"\n    def __init__(self, dim, length):",
        "detail": "robosuite.utils.control_utils",
        "documentation": {}
    },
    {
        "label": "DeltaBuffer",
        "kind": 6,
        "importPath": "robosuite.utils.control_utils",
        "description": "robosuite.utils.control_utils",
        "peekOfCode": "class DeltaBuffer(Buffer):\n    \"\"\"\n    Simple 2-length buffer object to streamline grabbing delta values between \"current\" and \"last\" values\n    Constructs delta object.\n    Args:\n        dim (int): Size of numerical arrays being inputted\n        init_value (None or Iterable): Initial value to fill \"last\" value with initially.\n            If None (default), last array will be filled with zeros\n    \"\"\"\n    def __init__(self, dim, init_value=None):",
        "detail": "robosuite.utils.control_utils",
        "documentation": {}
    },
    {
        "label": "nullspace_torques",
        "kind": 2,
        "importPath": "robosuite.utils.control_utils",
        "description": "robosuite.utils.control_utils",
        "peekOfCode": "def nullspace_torques(mass_matrix, nullspace_matrix, initial_joint, joint_pos, joint_vel, joint_kp=10):\n    \"\"\"\n    For a robot with redundant DOF(s), a nullspace exists which is orthogonal to the remainder of the controllable\n    subspace of the robot's joints. Therefore, an additional secondary objective that does not impact the original\n    controller objective may attempt to be maintained using these nullspace torques.\n    This utility function specifically calculates nullspace torques that attempt to maintain a given robot joint\n    positions @initial_joint with zero velocity using proportinal gain @joint_kp\n    :Note: @mass_matrix, @nullspace_matrix, @joint_pos, and @joint_vel should reflect the robot's state at the current\n    timestep\n    Args:",
        "detail": "robosuite.utils.control_utils",
        "documentation": {}
    },
    {
        "label": "opspace_matrices",
        "kind": 2,
        "importPath": "robosuite.utils.control_utils",
        "description": "robosuite.utils.control_utils",
        "peekOfCode": "def opspace_matrices(mass_matrix, J_full, J_pos, J_ori):\n    \"\"\"\n    Calculates the relevant matrices used in the operational space control algorithm\n    Args:\n        mass_matrix (np.array): 2d array representing the mass matrix of the robot\n        J_full (np.array): 2d array representing the full Jacobian matrix of the robot\n        J_pos (np.array): 2d array representing the position components of the Jacobian matrix of the robot\n        J_ori (np.array): 2d array representing the orientation components of the Jacobian matrix of the robot\n    Returns:\n        4-tuple:",
        "detail": "robosuite.utils.control_utils",
        "documentation": {}
    },
    {
        "label": "orientation_error",
        "kind": 2,
        "importPath": "robosuite.utils.control_utils",
        "description": "robosuite.utils.control_utils",
        "peekOfCode": "def orientation_error(desired, current):\n    \"\"\"\n    This function calculates a 3-dimensional orientation error vector for use in the\n    impedance controller. It does this by computing the delta rotation between the\n    inputs and converting that rotation to exponential coordinates (axis-angle\n    representation, where the 3d vector is axis * angle).\n    See https://en.wikipedia.org/wiki/Axis%E2%80%93angle_representation for more information.\n    Optimized function to determine orientation error from matrices\n    Args:\n        desired (np.array): 2d array representing target orientation matrix",
        "detail": "robosuite.utils.control_utils",
        "documentation": {}
    },
    {
        "label": "set_goal_position",
        "kind": 2,
        "importPath": "robosuite.utils.control_utils",
        "description": "robosuite.utils.control_utils",
        "peekOfCode": "def set_goal_position(delta,\n                      current_position,\n                      position_limit=None,\n                      set_pos=None):\n    \"\"\"\n    Calculates and returns the desired goal position, clipping the result accordingly to @position_limits.\n    @delta and @current_position must be specified if a relative goal is requested, else @set_pos must be\n    specified to define a global goal position\n    Args:\n        delta (np.array): Desired relative change in position",
        "detail": "robosuite.utils.control_utils",
        "documentation": {}
    },
    {
        "label": "set_goal_orientation",
        "kind": 2,
        "importPath": "robosuite.utils.control_utils",
        "description": "robosuite.utils.control_utils",
        "peekOfCode": "def set_goal_orientation(delta,\n                         current_orientation,\n                         orientation_limit=None,\n                         set_ori=None):\n    \"\"\"\n    Calculates and returns the desired goal orientation, clipping the result accordingly to @orientation_limits.\n    @delta and @current_orientation must be specified if a relative goal is requested, else @set_ori must be\n    an orientation matrix specified to define a global orientation\n    Args:\n        delta (np.array): Desired relative change in orientation, in axis-angle form [ax, ay, az]",
        "detail": "robosuite.utils.control_utils",
        "documentation": {}
    },
    {
        "label": "robosuiteError",
        "kind": 6,
        "importPath": "robosuite.utils.errors",
        "description": "robosuite.utils.errors",
        "peekOfCode": "class robosuiteError(Exception):\n    \"\"\"Base class for exceptions in robosuite.\"\"\"\n    pass\nclass XMLError(robosuiteError):\n    \"\"\"Exception raised for errors related to xml.\"\"\"\n    pass\nclass SimulationError(robosuiteError):\n    \"\"\"Exception raised for errors during runtime.\"\"\"\n    pass\nclass RandomizationError(robosuiteError):",
        "detail": "robosuite.utils.errors",
        "documentation": {}
    },
    {
        "label": "XMLError",
        "kind": 6,
        "importPath": "robosuite.utils.errors",
        "description": "robosuite.utils.errors",
        "peekOfCode": "class XMLError(robosuiteError):\n    \"\"\"Exception raised for errors related to xml.\"\"\"\n    pass\nclass SimulationError(robosuiteError):\n    \"\"\"Exception raised for errors during runtime.\"\"\"\n    pass\nclass RandomizationError(robosuiteError):\n    \"\"\"Exception raised for really really bad RNG.\"\"\"\n    pass",
        "detail": "robosuite.utils.errors",
        "documentation": {}
    },
    {
        "label": "SimulationError",
        "kind": 6,
        "importPath": "robosuite.utils.errors",
        "description": "robosuite.utils.errors",
        "peekOfCode": "class SimulationError(robosuiteError):\n    \"\"\"Exception raised for errors during runtime.\"\"\"\n    pass\nclass RandomizationError(robosuiteError):\n    \"\"\"Exception raised for really really bad RNG.\"\"\"\n    pass",
        "detail": "robosuite.utils.errors",
        "documentation": {}
    },
    {
        "label": "RandomizationError",
        "kind": 6,
        "importPath": "robosuite.utils.errors",
        "description": "robosuite.utils.errors",
        "peekOfCode": "class RandomizationError(robosuiteError):\n    \"\"\"Exception raised for really really bad RNG.\"\"\"\n    pass",
        "detail": "robosuite.utils.errors",
        "documentation": {}
    },
    {
        "label": "choose_environment",
        "kind": 2,
        "importPath": "robosuite.utils.input_utils",
        "description": "robosuite.utils.input_utils",
        "peekOfCode": "def choose_environment():\n    \"\"\"\n    Prints out environment options, and returns the selected env_name choice\n    Returns:\n        str: Chosen environment name\n    \"\"\"\n    # get the list of all environments\n    envs = sorted(suite.ALL_ENVIRONMENTS)\n    # Select environment to run\n    print(\"Here is a list of environments in the suite:\\n\")",
        "detail": "robosuite.utils.input_utils",
        "documentation": {}
    },
    {
        "label": "choose_controller",
        "kind": 2,
        "importPath": "robosuite.utils.input_utils",
        "description": "robosuite.utils.input_utils",
        "peekOfCode": "def choose_controller():\n    \"\"\"\n    Prints out controller options, and returns the requested controller name\n    Returns:\n        str: Chosen controller name\n    \"\"\"\n    # get the list of all controllers\n    controllers_info = suite.controllers.CONTROLLER_INFO\n    controllers = list(suite.ALL_CONTROLLERS)\n    # Select controller to use",
        "detail": "robosuite.utils.input_utils",
        "documentation": {}
    },
    {
        "label": "choose_multi_arm_config",
        "kind": 2,
        "importPath": "robosuite.utils.input_utils",
        "description": "robosuite.utils.input_utils",
        "peekOfCode": "def choose_multi_arm_config():\n    \"\"\"\n    Prints out multi-arm environment configuration options, and returns the requested config name\n    Returns:\n        str: Requested multi-arm configuration name\n    \"\"\"\n    # Get the list of all multi arm configs\n    env_configs = {\n        \"Single Arms Opposed\": \"single-arm-opposed\",\n        \"Single Arms Parallel\": \"single-arm-parallel\",",
        "detail": "robosuite.utils.input_utils",
        "documentation": {}
    },
    {
        "label": "choose_robots",
        "kind": 2,
        "importPath": "robosuite.utils.input_utils",
        "description": "robosuite.utils.input_utils",
        "peekOfCode": "def choose_robots(exclude_bimanual=False):\n    \"\"\"\n    Prints out robot options, and returns the requested robot. Restricts options to single-armed robots if\n    @exclude_bimanual is set to True (False by default)\n    Args:\n        exclude_bimanual (bool): If set, excludes bimanual robots from the robot options\n    Returns:\n        str: Requested robot name\n    \"\"\"\n    # Get the list of robots",
        "detail": "robosuite.utils.input_utils",
        "documentation": {}
    },
    {
        "label": "input2action",
        "kind": 2,
        "importPath": "robosuite.utils.input_utils",
        "description": "robosuite.utils.input_utils",
        "peekOfCode": "def input2action(device, robot, active_arm=\"right\", env_configuration=None):\n    \"\"\"\n    Converts an input from an active device into a valid action sequence that can be fed into an env.step() call\n    If a reset is triggered from the device, immediately returns None. Else, returns the appropriate action\n    Args:\n        device (Device): A device from which user inputs can be converted into actions. Can be either a Spacemouse or\n            Keyboard device class\n        robot (Robot): Which robot we're controlling\n        active_arm (str): Only applicable for multi-armed setups (e.g.: multi-arm environments or bimanual robots).\n            Allows inputs to be converted correctly if the control type (e.g.: IK) is dependent on arm choice.",
        "detail": "robosuite.utils.input_utils",
        "documentation": {}
    },
    {
        "label": "USING_INSTANCE_RANDOMIZATION",
        "kind": 5,
        "importPath": "robosuite.utils.macros",
        "description": "robosuite.utils.macros",
        "peekOfCode": "USING_INSTANCE_RANDOMIZATION = False\n# Numba settings\nENABLE_NUMBA = True\nCACHE_NUMBA = True\n# Image Convention\n# Robosuite (Mujoco)-rendered images are based on the OpenGL coordinate frame convention, whereas many downstream\n# applications assume an OpenCV coordinate frame convention. For consistency, you can set the image convention\n# here; this will assure that any rendered frames will match the associated convention.\n# See the figure at the bottom of https://amytabb.com/ts/2019_06_28/ for an informative overview.\nIMAGE_CONVENTION = \"opengl\"     # Options are {\"opengl\", \"opencv\"}",
        "detail": "robosuite.utils.macros",
        "documentation": {}
    },
    {
        "label": "ENABLE_NUMBA",
        "kind": 5,
        "importPath": "robosuite.utils.macros",
        "description": "robosuite.utils.macros",
        "peekOfCode": "ENABLE_NUMBA = True\nCACHE_NUMBA = True\n# Image Convention\n# Robosuite (Mujoco)-rendered images are based on the OpenGL coordinate frame convention, whereas many downstream\n# applications assume an OpenCV coordinate frame convention. For consistency, you can set the image convention\n# here; this will assure that any rendered frames will match the associated convention.\n# See the figure at the bottom of https://amytabb.com/ts/2019_06_28/ for an informative overview.\nIMAGE_CONVENTION = \"opengl\"     # Options are {\"opengl\", \"opencv\"}",
        "detail": "robosuite.utils.macros",
        "documentation": {}
    },
    {
        "label": "CACHE_NUMBA",
        "kind": 5,
        "importPath": "robosuite.utils.macros",
        "description": "robosuite.utils.macros",
        "peekOfCode": "CACHE_NUMBA = True\n# Image Convention\n# Robosuite (Mujoco)-rendered images are based on the OpenGL coordinate frame convention, whereas many downstream\n# applications assume an OpenCV coordinate frame convention. For consistency, you can set the image convention\n# here; this will assure that any rendered frames will match the associated convention.\n# See the figure at the bottom of https://amytabb.com/ts/2019_06_28/ for an informative overview.\nIMAGE_CONVENTION = \"opengl\"     # Options are {\"opengl\", \"opencv\"}",
        "detail": "robosuite.utils.macros",
        "documentation": {}
    },
    {
        "label": "IMAGE_CONVENTION",
        "kind": 5,
        "importPath": "robosuite.utils.macros",
        "description": "robosuite.utils.macros",
        "peekOfCode": "IMAGE_CONVENTION = \"opengl\"     # Options are {\"opengl\", \"opencv\"}",
        "detail": "robosuite.utils.macros",
        "documentation": {}
    },
    {
        "label": "CustomMaterial",
        "kind": 6,
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "peekOfCode": "class CustomMaterial(object):\n    \"\"\"\n    Simple class to instantiate the necessary parameters to define an appropriate texture / material combo\n    Instantiates a nested dict holding necessary components for procedurally generating a texture / material combo\n    Please see http://www.mujoco.org/book/XMLreference.html#asset for specific details on\n        attributes expected for Mujoco texture / material tags, respectively\n    Note that the values in @tex_attrib and @mat_attrib can be in string or array / numerical form.\n    Args:\n        texture (None or str or 4-array): Name of texture file to be imported. If a string, should be part of\n            ALL_TEXTURES. If texture is a 4-array, then this argument will be interpreted as an rgba tuple value and",
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "xml_path_completion",
        "kind": 2,
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "peekOfCode": "def xml_path_completion(xml_path):\n    \"\"\"\n    Takes in a local xml path and returns a full path.\n        if @xml_path is absolute, do nothing\n        if @xml_path is not absolute, load xml that is shipped by the package\n    Args:\n        xml_path (str): local xml path\n    Returns:\n        str: Full (absolute) xml path\n    \"\"\"",
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "array_to_string",
        "kind": 2,
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "peekOfCode": "def array_to_string(array):\n    \"\"\"\n    Converts a numeric array into the string format in mujoco.\n    Examples:\n        [0, 1, 2] => \"0 1 2\"\n    Args:\n        array (n-array): Array to convert to a string\n    Returns:\n        str: String equivalent of @array\n    \"\"\"",
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "string_to_array",
        "kind": 2,
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "peekOfCode": "def string_to_array(string):\n    \"\"\"\n    Converts a array string in mujoco xml to np.array.\n    Examples:\n        \"0 1 2\" => [0, 1, 2]\n    Args:\n        string (str): String to convert to an array\n    Returns:\n        np.array: Numerical array equivalent of @string\n    \"\"\"",
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "convert_to_string",
        "kind": 2,
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "peekOfCode": "def convert_to_string(inp):\n    \"\"\"\n    Converts any type of {bool, int, float, list, tuple, array, string, np.str_} into an mujoco-xml compatible string.\n        Note that an input string / np.str_ results in a no-op action.\n    Args:\n        inp: Input to convert to string\n    Returns:\n        str: String equivalent of @inp\n    \"\"\"\n    if type(inp) in {list, tuple, np.ndarray}:",
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "set_alpha",
        "kind": 2,
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "peekOfCode": "def set_alpha(node, alpha=0.1):\n    \"\"\"\n    Sets all a(lpha) field of the rgba attribute to be @alpha\n    for @node and all subnodes\n    used for managing display\n    Args:\n        node (ET.Element): Specific node element within XML tree\n        alpha (float): Value to set alpha value of rgba tuple\n    \"\"\"\n    for child_node in node.findall(\".//*[@rgba]\"):",
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "new_element",
        "kind": 2,
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "peekOfCode": "def new_element(tag, name, **kwargs):\n    \"\"\"\n    Creates a new @tag element with attributes specified by @**kwargs.\n    Args:\n        tag (str): Type of element to create\n        name (None or str): Name for this element. Should only be None for elements that do not have an explicit\n            name attribute (e.g.: inertial elements)\n        **kwargs: Specified attributes for the new joint\n    Returns:\n        ET.Element: new specified xml element",
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "new_joint",
        "kind": 2,
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "peekOfCode": "def new_joint(name, **kwargs):\n    \"\"\"\n    Creates a joint tag with attributes specified by @**kwargs.\n    Args:\n        name (str): Name for this joint\n        **kwargs: Specified attributes for the new joint\n    Returns:\n        ET.Element: new joint xml element\n    \"\"\"\n    return new_element(tag=\"joint\", name=name, **kwargs)",
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "new_actuator",
        "kind": 2,
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "peekOfCode": "def new_actuator(name, joint, act_type=\"actuator\", **kwargs):\n    \"\"\"\n    Creates an actuator tag with attributes specified by @**kwargs.\n    Args:\n        name (str): Name for this actuator\n        joint (str): type of actuator transmission.\n            see all types here: http://mujoco.org/book/modeling.html#actuator\n        act_type (str): actuator type. Defaults to \"actuator\"\n        **kwargs: Any additional specified attributes for the new joint\n    Returns:",
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "new_site",
        "kind": 2,
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "peekOfCode": "def new_site(name, rgba=RED, pos=(0, 0, 0), size=(0.005,), **kwargs):\n    \"\"\"\n    Creates a site element with attributes specified by @**kwargs.\n    NOTE: With the exception of @name, @pos, and @size, if any arg is set to\n        None, the value will automatically be popped before passing the values\n        to create the appropriate XML\n    Args:\n        name (str): Name for this site\n        rgba (4-array): (r,g,b,a) color and transparency. Defaults to solid red.\n        pos (3-array): (x,y,z) 3d position of the site.",
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "new_geom",
        "kind": 2,
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "peekOfCode": "def new_geom(name, type, size, pos=(0, 0, 0), group=0, **kwargs):\n    \"\"\"\n    Creates a geom element with attributes specified by @**kwargs.\n    NOTE: With the exception of @geom_type, @size, and @pos, if any arg is set to\n        None, the value will automatically be popped before passing the values\n        to create the appropriate XML\n    Args:\n        name (str): Name for this geom\n        type (str): type of the geom.\n            see all types here: http://mujoco.org/book/modeling.html#geom",
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "new_body",
        "kind": 2,
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "peekOfCode": "def new_body(name, pos=(0, 0, 0), **kwargs):\n    \"\"\"\n    Creates a body element with attributes specified by @**kwargs.\n    Args:\n        name (str): Name for this body\n        pos (3-array): (x,y,z) 3d position of the body frame.\n        **kwargs: Any additional specified attributes for the new body\n    Returns:\n        ET.Element: new body xml element\n    \"\"\"",
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "new_inertial",
        "kind": 2,
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "peekOfCode": "def new_inertial(pos=(0, 0, 0), mass=None, **kwargs):\n    \"\"\"\n    Creates a inertial element with attributes specified by @**kwargs.\n    Args:\n        pos (3-array): (x,y,z) 3d position of the inertial frame.\n        mass (float): The mass of inertial\n        **kwargs: Any additional specified attributes for the new inertial element\n    Returns:\n        ET.Element: new inertial xml element\n    \"\"\"",
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "get_size",
        "kind": 2,
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "peekOfCode": "def get_size(size,\n             size_max,\n             size_min,\n             default_max,\n             default_min):\n    \"\"\"\n    Helper method for providing a size, or a range to randomize from\n    Args:\n        size (n-array): Array of numbers that explicitly define the size\n        size_max (n-array): Array of numbers that define the custom max size from which to randomly sample",
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "postprocess_model_xml",
        "kind": 2,
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "peekOfCode": "def postprocess_model_xml(xml_str):\n    \"\"\"\n    This function postprocesses the model.xml collected from a MuJoCo demonstration\n    in order to make sure that the STL files can be found.\n    Args:\n        xml_str (str): Mujoco sim demonstration XML file as string\n    Returns:\n        str: Post-processed xml file as string\n    \"\"\"\n    path = os.path.split(robosuite.__file__)[0]",
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "add_to_dict",
        "kind": 2,
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "peekOfCode": "def add_to_dict(dic, fill_in_defaults=True, default_value=None, **kwargs):\n    \"\"\"\n    Helper function to add key-values to dictionary @dic where each entry is its own array (list).\n    Args:\n        dic (dict): Dictionary to which new key / value pairs will be added. If the key already exists,\n            will append the value to that key entry\n        fill_in_defaults (bool): If True, will automatically add @default_value to all dictionary entries that are\n            not explicitly specified in @kwargs\n        default_value (any): Default value to fill (None by default)\n    Returns:",
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "add_prefix",
        "kind": 2,
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "peekOfCode": "def add_prefix(\n        root,\n        prefix,\n        tags=\"default\",\n        attribs=\"default\",\n        exclude=None,\n):\n    \"\"\"\n    Find all element(s) matching the requested @tag, and appends @prefix to all @attributes if they exist.\n    Args:",
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "add_material",
        "kind": 2,
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "peekOfCode": "def add_material(root, naming_prefix=\"\", custom_material=None):\n    \"\"\"\n    Iterates through all element(s) in @root recursively and adds a material / texture to all visual geoms that don't\n    already have a material specified.\n    Args:\n        root (ET.Element): Root of the xml element tree to start recursively searching through.\n        naming_prefix (str): Adds this prefix to all material and texture names\n        custom_material (None or CustomMaterial): If specified, will add this material to all visual geoms.\n            Else, will add a default \"no-change\" material.\n    Returns:",
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "recolor_collision_geoms",
        "kind": 2,
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "peekOfCode": "def recolor_collision_geoms(root, rgba, exclude=None):\n    \"\"\"\n    Iteratively searches through all elements starting with @root to find all geoms belonging to group 0 and set\n    the corresponding rgba value to the specified @rgba argument. Note: also removes any material values for these\n    elements.\n    Args:\n        root (ET.Element): Root of the xml element tree to start recursively searching through\n        rgba (4-array): (R, G, B, A) values to assign to all geoms with this group.\n        exclude (None or function): Filtering function that should take in an ET.Element and\n            return True if we should exclude the given element / attribute from having its collision geom impacted.",
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "sort_elements",
        "kind": 2,
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "peekOfCode": "def sort_elements(root, parent=None, element_filter=None, _elements_dict=None):\n    \"\"\"\n    Utility method to iteratively sort all elements based on @tags. This XML ElementTree will be parsed such that\n    all elements with the same key as returned by @element_filter will be grouped as a list entry in the returned\n    dictionary.\n    Args:\n        root (ET.Element): Root of the xml element tree to start recursively searching through\n        parent (ET.Element): Parent of the root node. Default is None (no parent node initially)\n        element_filter (None or function): Function used to filter the incoming elements. Should take in two\n            ET.Elements (current_element, parent_element) and return a string filter_key if the element",
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "find_elements",
        "kind": 2,
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "peekOfCode": "def find_elements(root, tags, attribs, return_first=True):\n    \"\"\"\n    Find all element(s) matching the requested @tag and @attributes. If @return_first is True, then will return the\n    first element found matching the criteria specified. Otherwise, will return a list of elements that match the\n    criteria.\n    Args:\n        root (ET.Element): Root of the xml element tree to start recursively searching through. Default is None\n            (use automatic top-level root in this XML object)\n        tags (str or list of str or set): Tag(s) to search for in this ElementTree.\n        attribs (dict of str): Element attribute(s) to check against for a filtered element. A match is",
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "save_sim_model",
        "kind": 2,
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "peekOfCode": "def save_sim_model(sim, fname):\n    \"\"\"\n    Saves the current model xml from @sim at file location @fname.\n    Args:\n        sim (MjSim): XML file to save, in string form\n        fname (str): Absolute filepath to the location to save the file\n    \"\"\"\n    with open(fname, \"w\") as f:\n        sim.save(file=f, format=\"xml\")",
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "RED",
        "kind": 5,
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "peekOfCode": "RED = [1, 0, 0, 1]\nGREEN = [0, 1, 0, 1]\nBLUE = [0, 0, 1, 1]\nCYAN = [0, 1, 1, 1]\nROBOT_COLLISION_COLOR = [0, 0.5, 0, 1]\nMOUNT_COLLISION_COLOR = [0.5, 0.5, 0, 1]\nGRIPPER_COLLISION_COLOR = [0, 0, 0.5, 1]\nOBJECT_COLLISION_COLOR = [0.5, 0, 0, 1]\nENVIRONMENT_COLLISION_COLOR = [0.5, 0.5, 0, 1]\nSENSOR_TYPES = {",
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "GREEN",
        "kind": 5,
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "peekOfCode": "GREEN = [0, 1, 0, 1]\nBLUE = [0, 0, 1, 1]\nCYAN = [0, 1, 1, 1]\nROBOT_COLLISION_COLOR = [0, 0.5, 0, 1]\nMOUNT_COLLISION_COLOR = [0.5, 0.5, 0, 1]\nGRIPPER_COLLISION_COLOR = [0, 0, 0.5, 1]\nOBJECT_COLLISION_COLOR = [0.5, 0, 0, 1]\nENVIRONMENT_COLLISION_COLOR = [0.5, 0.5, 0, 1]\nSENSOR_TYPES = {\n    \"touch\",",
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "BLUE",
        "kind": 5,
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "peekOfCode": "BLUE = [0, 0, 1, 1]\nCYAN = [0, 1, 1, 1]\nROBOT_COLLISION_COLOR = [0, 0.5, 0, 1]\nMOUNT_COLLISION_COLOR = [0.5, 0.5, 0, 1]\nGRIPPER_COLLISION_COLOR = [0, 0, 0.5, 1]\nOBJECT_COLLISION_COLOR = [0.5, 0, 0, 1]\nENVIRONMENT_COLLISION_COLOR = [0.5, 0.5, 0, 1]\nSENSOR_TYPES = {\n    \"touch\",\n    \"accelerometer\",",
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "CYAN",
        "kind": 5,
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "peekOfCode": "CYAN = [0, 1, 1, 1]\nROBOT_COLLISION_COLOR = [0, 0.5, 0, 1]\nMOUNT_COLLISION_COLOR = [0.5, 0.5, 0, 1]\nGRIPPER_COLLISION_COLOR = [0, 0, 0.5, 1]\nOBJECT_COLLISION_COLOR = [0.5, 0, 0, 1]\nENVIRONMENT_COLLISION_COLOR = [0.5, 0.5, 0, 1]\nSENSOR_TYPES = {\n    \"touch\",\n    \"accelerometer\",\n    \"velocimeter\",",
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "ROBOT_COLLISION_COLOR",
        "kind": 5,
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "peekOfCode": "ROBOT_COLLISION_COLOR = [0, 0.5, 0, 1]\nMOUNT_COLLISION_COLOR = [0.5, 0.5, 0, 1]\nGRIPPER_COLLISION_COLOR = [0, 0, 0.5, 1]\nOBJECT_COLLISION_COLOR = [0.5, 0, 0, 1]\nENVIRONMENT_COLLISION_COLOR = [0.5, 0.5, 0, 1]\nSENSOR_TYPES = {\n    \"touch\",\n    \"accelerometer\",\n    \"velocimeter\",\n    \"gyro\",",
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "MOUNT_COLLISION_COLOR",
        "kind": 5,
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "peekOfCode": "MOUNT_COLLISION_COLOR = [0.5, 0.5, 0, 1]\nGRIPPER_COLLISION_COLOR = [0, 0, 0.5, 1]\nOBJECT_COLLISION_COLOR = [0.5, 0, 0, 1]\nENVIRONMENT_COLLISION_COLOR = [0.5, 0.5, 0, 1]\nSENSOR_TYPES = {\n    \"touch\",\n    \"accelerometer\",\n    \"velocimeter\",\n    \"gyro\",\n    \"force\",",
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "GRIPPER_COLLISION_COLOR",
        "kind": 5,
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "peekOfCode": "GRIPPER_COLLISION_COLOR = [0, 0, 0.5, 1]\nOBJECT_COLLISION_COLOR = [0.5, 0, 0, 1]\nENVIRONMENT_COLLISION_COLOR = [0.5, 0.5, 0, 1]\nSENSOR_TYPES = {\n    \"touch\",\n    \"accelerometer\",\n    \"velocimeter\",\n    \"gyro\",\n    \"force\",\n    \"torque\",",
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "OBJECT_COLLISION_COLOR",
        "kind": 5,
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "peekOfCode": "OBJECT_COLLISION_COLOR = [0.5, 0, 0, 1]\nENVIRONMENT_COLLISION_COLOR = [0.5, 0.5, 0, 1]\nSENSOR_TYPES = {\n    \"touch\",\n    \"accelerometer\",\n    \"velocimeter\",\n    \"gyro\",\n    \"force\",\n    \"torque\",\n    \"magnetometer\",",
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "ENVIRONMENT_COLLISION_COLOR",
        "kind": 5,
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "peekOfCode": "ENVIRONMENT_COLLISION_COLOR = [0.5, 0.5, 0, 1]\nSENSOR_TYPES = {\n    \"touch\",\n    \"accelerometer\",\n    \"velocimeter\",\n    \"gyro\",\n    \"force\",\n    \"torque\",\n    \"magnetometer\",\n    \"rangefinder\",",
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "SENSOR_TYPES",
        "kind": 5,
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "peekOfCode": "SENSOR_TYPES = {\n    \"touch\",\n    \"accelerometer\",\n    \"velocimeter\",\n    \"gyro\",\n    \"force\",\n    \"torque\",\n    \"magnetometer\",\n    \"rangefinder\",\n    \"jointpos\",",
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "MUJOCO_NAMED_ATTRIBUTES",
        "kind": 5,
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "peekOfCode": "MUJOCO_NAMED_ATTRIBUTES = {\n    \"class\", \"childclass\", \"name\", \"objname\", \"material\", \"texture\",\n    \"joint\", \"joint1\", \"joint2\", \"jointinparent\", \"geom\", \"geom1\", \"geom2\",\n    \"mesh\", \"fixed\", \"actuator\", \"objname\", \"tendon\", \"tendon1\", \"tendon2\",\n    \"slidesite\", \"cranksite\", \"body\", \"body1\", \"body2\", \"hfield\", \"target\",\n    \"prefix\", \"site\",\n}\nIMAGE_CONVENTION_MAPPING = {\n    \"opengl\": 1,\n    \"opencv\": -1,",
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "IMAGE_CONVENTION_MAPPING",
        "kind": 5,
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "peekOfCode": "IMAGE_CONVENTION_MAPPING = {\n    \"opengl\": 1,\n    \"opencv\": -1,\n}\nTEXTURES = {\n    \"WoodRed\": \"red-wood.png\",\n    \"WoodGreen\": \"green-wood.png\",\n    \"WoodBlue\": \"blue-wood.png\",\n    \"WoodLight\": \"light-wood.png\",\n    \"WoodDark\": \"dark-wood.png\",",
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "TEXTURES",
        "kind": 5,
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "peekOfCode": "TEXTURES = {\n    \"WoodRed\": \"red-wood.png\",\n    \"WoodGreen\": \"green-wood.png\",\n    \"WoodBlue\": \"blue-wood.png\",\n    \"WoodLight\": \"light-wood.png\",\n    \"WoodDark\": \"dark-wood.png\",\n    \"WoodTiles\": \"wood-tiles.png\",\n    \"WoodPanels\": \"wood-varnished-panels.png\",\n    \"WoodgrainGray\": \"gray-woodgrain.png\",\n    \"PlasterCream\": \"cream-plaster.png\",",
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "ALL_TEXTURES",
        "kind": 5,
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "peekOfCode": "ALL_TEXTURES = TEXTURES.keys()\nclass CustomMaterial(object):\n    \"\"\"\n    Simple class to instantiate the necessary parameters to define an appropriate texture / material combo\n    Instantiates a nested dict holding necessary components for procedurally generating a texture / material combo\n    Please see http://www.mujoco.org/book/XMLreference.html#asset for specific details on\n        attributes expected for Mujoco texture / material tags, respectively\n    Note that the values in @tex_attrib and @mat_attrib can be in string or array / numerical form.\n    Args:\n        texture (None or str or 4-array): Name of texture file to be imported. If a string, should be part of",
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "BaseModder",
        "kind": 6,
        "importPath": "robosuite.utils.mjmod",
        "description": "robosuite.utils.mjmod",
        "peekOfCode": "class BaseModder():\n    \"\"\"\n    Base class meant to modify simulation attributes mid-sim.\n    Using @random_state ensures that sampling here won't be affected\n    by sampling that happens outside of the modders.\n    Args:\n        sim (MjSim): simulation object\n        random_state (RandomState): instance of np.random.RandomState, specific\n            seed used to randomize these modifications without impacting other\n            numpy seeds / randomizations",
        "detail": "robosuite.utils.mjmod",
        "documentation": {}
    },
    {
        "label": "LightingModder",
        "kind": 6,
        "importPath": "robosuite.utils.mjmod",
        "description": "robosuite.utils.mjmod",
        "peekOfCode": "class LightingModder(BaseModder):\n    \"\"\"\n    Modder to modify lighting within a Mujoco simulation.\n    Args:\n        sim (MjSim): MjSim object\n        random_state (RandomState): instance of np.random.RandomState\n        light_names (None or list of str): list of lights to use for randomization. If not provided, all\n            lights in the model are randomized.\n        randomize_position (bool): If True, randomizes position of lighting\n        randomize_direction (bool): If True, randomizes direction of lighting",
        "detail": "robosuite.utils.mjmod",
        "documentation": {}
    },
    {
        "label": "CameraModder",
        "kind": 6,
        "importPath": "robosuite.utils.mjmod",
        "description": "robosuite.utils.mjmod",
        "peekOfCode": "class CameraModder(BaseModder):\n    \"\"\"\n    Modder for modifying camera attributes in mujoco sim\n    Args:\n        sim (MjSim): MjSim object\n        random_state (None or RandomState): instance of np.random.RandomState\n        camera_names (None or list of str): list of camera names to use for randomization. If not provided,\n            all cameras are used for randomization.\n        randomize_position (bool): if True, randomize camera position\n        randomize_rotation (bool): if True, randomize camera rotation",
        "detail": "robosuite.utils.mjmod",
        "documentation": {}
    },
    {
        "label": "TextureModder",
        "kind": 6,
        "importPath": "robosuite.utils.mjmod",
        "description": "robosuite.utils.mjmod",
        "peekOfCode": "class TextureModder(BaseModder):\n    \"\"\"\n    Modify textures in model. Example use:\n        sim = MjSim(...)\n        modder = TextureModder(sim)\n        modder.whiten_materials()  # ensures materials won't impact colors\n        modder.set_checker('some_geom', (255, 0, 0), (0, 0, 0))\n        modder.rand_all('another_geom')\n    Note: in order for the textures to take full effect, you'll need to set\n    the rgba values for all materials to [1, 1, 1, 1], otherwise the texture",
        "detail": "robosuite.utils.mjmod",
        "documentation": {}
    },
    {
        "label": "Texture",
        "kind": 6,
        "importPath": "robosuite.utils.mjmod",
        "description": "robosuite.utils.mjmod",
        "peekOfCode": "class Texture:\n    \"\"\"\n    Helper class for operating on the MuJoCo textures.\n    Args:\n        model (MjModel): Mujoco sim model\n        tex_id (int): id of specific texture in mujoco sim\n    \"\"\"\n    __slots__ = ['id', 'type', 'height', 'width', 'tex_adr', 'tex_rgb']\n    def __init__(self, model, tex_id):\n        self.id = tex_id",
        "detail": "robosuite.utils.mjmod",
        "documentation": {}
    },
    {
        "label": "PhysicalParameterModder",
        "kind": 6,
        "importPath": "robosuite.utils.mjmod",
        "description": "robosuite.utils.mjmod",
        "peekOfCode": "class PhysicalParameterModder(BaseModder):\n    \"\"\"\n    Modder for various physical parameters of the mujoco model\n    can use to modify parameters stored in MjModel (ie friction, damping, etc.) as\n    well as optimizer parameters like global friction multipliers (eg solimp, solref, etc)\n    To modify a parameteter, use the parameter to be changed as a keyword argument to\n    self.mod and the new value as the value for that argument. Supports arbitray many\n    modifications in a single step.\n    :NOTE: It is necesary to perform sim.forward after performing the modification.\n    :NOTE: Some parameters might not be able to be changed. users are to verify that",
        "detail": "robosuite.utils.mjmod",
        "documentation": {}
    },
    {
        "label": "MJT_TEXTURE_ENUM",
        "kind": 5,
        "importPath": "robosuite.utils.mjmod",
        "description": "robosuite.utils.mjmod",
        "peekOfCode": "MJT_TEXTURE_ENUM = ['2d', 'cube', 'skybox']\nclass Texture:\n    \"\"\"\n    Helper class for operating on the MuJoCo textures.\n    Args:\n        model (MjModel): Mujoco sim model\n        tex_id (int): id of specific texture in mujoco sim\n    \"\"\"\n    __slots__ = ['id', 'type', 'height', 'width', 'tex_adr', 'tex_rgb']\n    def __init__(self, model, tex_id):",
        "detail": "robosuite.utils.mjmod",
        "documentation": {}
    },
    {
        "label": "CustomMjViewer",
        "kind": 6,
        "importPath": "robosuite.utils.mujoco_py_renderer",
        "description": "robosuite.utils.mujoco_py_renderer",
        "peekOfCode": "class CustomMjViewer(MjViewer):\n    \"\"\"\n    Custom class extending the vanilla MjViewer class to add additional key-stroke callbacks\n    \"\"\"\n    keypress = defaultdict(list)\n    keyup = defaultdict(list)\n    keyrepeat = defaultdict(list)\n    def key_callback(self, window, key, scancode, action, mods):\n        \"\"\"\n        Processes key callbacks from the glfw renderer",
        "detail": "robosuite.utils.mujoco_py_renderer",
        "documentation": {}
    },
    {
        "label": "MujocoPyRenderer",
        "kind": 6,
        "importPath": "robosuite.utils.mujoco_py_renderer",
        "description": "robosuite.utils.mujoco_py_renderer",
        "peekOfCode": "class MujocoPyRenderer:\n    \"\"\"\n    Mujoco-py renderer object\n    Args:\n        sim: MjSim object\n    \"\"\"\n    def __init__(self, sim):\n        self.viewer = CustomMjViewer(sim)\n        self.callbacks = {}\n    def set_camera(self, camera_id):",
        "detail": "robosuite.utils.mujoco_py_renderer",
        "documentation": {}
    },
    {
        "label": "jit_decorator",
        "kind": 2,
        "importPath": "robosuite.utils.numba",
        "description": "robosuite.utils.numba",
        "peekOfCode": "def jit_decorator(func):\n    if macros.ENABLE_NUMBA:\n        return numba.jit(nopython=True, cache=macros.CACHE_NUMBA)(func)\n    return func",
        "detail": "robosuite.utils.numba",
        "documentation": {}
    },
    {
        "label": "ObjectPositionSampler",
        "kind": 6,
        "importPath": "robosuite.utils.placement_samplers",
        "description": "robosuite.utils.placement_samplers",
        "peekOfCode": "class ObjectPositionSampler:\n    \"\"\"\n    Base class of object placement sampler.\n    Args:\n        name (str): Name of this sampler.\n        mujoco_objects (None or MujocoObject or list of MujocoObject): single model or list of MJCF object models\n        ensure_object_boundary_in_range (bool): If True, will ensure that the object is enclosed within a given boundary\n            (should be implemented by subclass)\n        ensure_valid_placement (bool): If True, will check for correct (valid) object placements\n        reference_pos (3-array): global (x,y,z) position relative to which sampling will occur",
        "detail": "robosuite.utils.placement_samplers",
        "documentation": {}
    },
    {
        "label": "UniformRandomSampler",
        "kind": 6,
        "importPath": "robosuite.utils.placement_samplers",
        "description": "robosuite.utils.placement_samplers",
        "peekOfCode": "class UniformRandomSampler(ObjectPositionSampler):\n    \"\"\"\n    Places all objects within the table uniformly random.\n    Args:\n        name (str): Name of this sampler.\n        mujoco_objects (None or MujocoObject or list of MujocoObject): single model or list of MJCF object models\n        x_range (2-array of float): Specify the (min, max) relative x_range used to uniformly place objects\n        y_range (2-array of float): Specify the (min, max) relative y_range used to uniformly place objects\n        rotation (None or float or Iterable):\n            :`None`: Add uniform random random rotation",
        "detail": "robosuite.utils.placement_samplers",
        "documentation": {}
    },
    {
        "label": "SequentialCompositeSampler",
        "kind": 6,
        "importPath": "robosuite.utils.placement_samplers",
        "description": "robosuite.utils.placement_samplers",
        "peekOfCode": "class SequentialCompositeSampler(ObjectPositionSampler):\n    \"\"\"\n    Samples position for each object sequentially. Allows chaining\n    multiple placement initializers together - so that object locations can\n    be sampled on top of other objects or relative to other object placements.\n    Args:\n        name (str): Name of this sampler.\n    \"\"\"\n    def __init__(self, name):\n        # Samplers / args will be filled in later",
        "detail": "robosuite.utils.placement_samplers",
        "documentation": {}
    },
    {
        "label": "check_bimanual",
        "kind": 2,
        "importPath": "robosuite.utils.robot_utils",
        "description": "robosuite.utils.robot_utils",
        "peekOfCode": "def check_bimanual(robot_name):\n    \"\"\"\n    Utility function that returns whether the inputted robot_name is a bimanual robot or not\n    Args:\n        robot_name (str): Name of the robot to check\n    Returns:\n        bool: True if the inputted robot is a bimanual robot\n    \"\"\"\n    return robot_name.lower() in BIMANUAL_ROBOTS",
        "detail": "robosuite.utils.robot_utils",
        "documentation": {}
    },
    {
        "label": "convert_quat",
        "kind": 2,
        "importPath": "robosuite.utils.transform_utils",
        "description": "robosuite.utils.transform_utils",
        "peekOfCode": "def convert_quat(q, to=\"xyzw\"):\n    \"\"\"\n    Converts quaternion from one convention to another.\n    The convention to convert TO is specified as an optional argument.\n    If to == 'xyzw', then the input is in 'wxyz' format, and vice-versa.\n    Args:\n        q (np.array): a 4-dim array corresponding to a quaternion\n        to (str): either 'xyzw' or 'wxyz', determining which convention to convert to.\n    \"\"\"\n    if to == \"xyzw\":",
        "detail": "robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "quat_multiply",
        "kind": 2,
        "importPath": "robosuite.utils.transform_utils",
        "description": "robosuite.utils.transform_utils",
        "peekOfCode": "def quat_multiply(quaternion1, quaternion0):\n    \"\"\"\n    Return multiplication of two quaternions (q1 * q0).\n    E.g.:\n    >>> q = quat_multiply([1, -2, 3, 4], [-5, 6, 7, 8])\n    >>> np.allclose(q, [-44, -14, 48, 28])\n    True\n    Args:\n        quaternion1 (np.array): (x,y,z,w) quaternion\n        quaternion0 (np.array): (x,y,z,w) quaternion",
        "detail": "robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "quat_conjugate",
        "kind": 2,
        "importPath": "robosuite.utils.transform_utils",
        "description": "robosuite.utils.transform_utils",
        "peekOfCode": "def quat_conjugate(quaternion):\n    \"\"\"\n    Return conjugate of quaternion.\n    E.g.:\n    >>> q0 = random_quaternion()\n    >>> q1 = quat_conjugate(q0)\n    >>> q1[3] == q0[3] and all(q1[:3] == -q0[:3])\n    True\n    Args:\n        quaternion (np.array): (x,y,z,w) quaternion",
        "detail": "robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "quat_inverse",
        "kind": 2,
        "importPath": "robosuite.utils.transform_utils",
        "description": "robosuite.utils.transform_utils",
        "peekOfCode": "def quat_inverse(quaternion):\n    \"\"\"\n    Return inverse of quaternion.\n    E.g.:\n    >>> q0 = random_quaternion()\n    >>> q1 = quat_inverse(q0)\n    >>> np.allclose(quat_multiply(q0, q1), [0, 0, 0, 1])\n    True\n    Args:\n        quaternion (np.array): (x,y,z,w) quaternion",
        "detail": "robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "quat_distance",
        "kind": 2,
        "importPath": "robosuite.utils.transform_utils",
        "description": "robosuite.utils.transform_utils",
        "peekOfCode": "def quat_distance(quaternion1, quaternion0):\n    \"\"\"\n    Returns distance between two quaternions, such that distance * quaternion0 = quaternion1\n    Args:\n        quaternion1 (np.array): (x,y,z,w) quaternion\n        quaternion0 (np.array): (x,y,z,w) quaternion\n    Returns:\n        np.array: (x,y,z,w) quaternion distance\n    \"\"\"\n    return quat_multiply(quaternion1, quat_inverse(quaternion0))",
        "detail": "robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "quat_slerp",
        "kind": 2,
        "importPath": "robosuite.utils.transform_utils",
        "description": "robosuite.utils.transform_utils",
        "peekOfCode": "def quat_slerp(quat0, quat1, fraction, shortestpath=True):\n    \"\"\"\n    Return spherical linear interpolation between two quaternions.\n    E.g.:\n    >>> q0 = random_quat()\n    >>> q1 = random_quat()\n    >>> q = quat_slerp(q0, q1, 0.0)\n    >>> np.allclose(q, q0)\n    True\n    >>> q = quat_slerp(q0, q1, 1.0)",
        "detail": "robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "random_quat",
        "kind": 2,
        "importPath": "robosuite.utils.transform_utils",
        "description": "robosuite.utils.transform_utils",
        "peekOfCode": "def random_quat(rand=None):\n    \"\"\"\n    Return uniform random unit quaternion.\n    E.g.:\n    >>> q = random_quat()\n    >>> np.allclose(1.0, vector_norm(q))\n    True\n    >>> q = random_quat(np.random.random(3))\n    >>> q.shape\n    (4,)",
        "detail": "robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "random_axis_angle",
        "kind": 2,
        "importPath": "robosuite.utils.transform_utils",
        "description": "robosuite.utils.transform_utils",
        "peekOfCode": "def random_axis_angle(angle_limit=None, random_state=None):\n    \"\"\"\n    Samples an axis-angle rotation by first sampling a random axis\n    and then sampling an angle. If @angle_limit is provided, the size\n    of the rotation angle is constrained. \n    If @random_state is provided (instance of np.random.RandomState), it\n    will be used to generate random numbers.\n    Args:\n        angle_limit (None or float): If set, determines magnitude limit of angles to generate\n        random_state (None or RandomState): RNG to use if specified",
        "detail": "robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "vec",
        "kind": 2,
        "importPath": "robosuite.utils.transform_utils",
        "description": "robosuite.utils.transform_utils",
        "peekOfCode": "def vec(values):\n    \"\"\"\n    Converts value tuple into a numpy vector.\n    Args:\n        values (n-array): a tuple of numbers\n    Returns:\n        np.array: vector of given values\n    \"\"\"\n    return np.array(values, dtype=np.float32)\ndef mat4(array):",
        "detail": "robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "mat4",
        "kind": 2,
        "importPath": "robosuite.utils.transform_utils",
        "description": "robosuite.utils.transform_utils",
        "peekOfCode": "def mat4(array):\n    \"\"\"\n    Converts an array to 4x4 matrix.\n    Args:\n        array (n-array): the array in form of vec, list, or tuple\n    Returns:\n        np.array: a 4x4 numpy matrix\n    \"\"\"\n    return np.array(array, dtype=np.float32).reshape((4, 4))\ndef mat2pose(hmat):",
        "detail": "robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "mat2pose",
        "kind": 2,
        "importPath": "robosuite.utils.transform_utils",
        "description": "robosuite.utils.transform_utils",
        "peekOfCode": "def mat2pose(hmat):\n    \"\"\"\n    Converts a homogeneous 4x4 matrix into pose.\n    Args:\n        hmat (np.array): a 4x4 homogeneous matrix\n    Returns:\n        2-tuple:\n            - (np.array) (x,y,z) position array in cartesian coordinates\n            - (np.array) (x,y,z,w) orientation array in quaternion form\n    \"\"\"",
        "detail": "robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "mat2quat",
        "kind": 2,
        "importPath": "robosuite.utils.transform_utils",
        "description": "robosuite.utils.transform_utils",
        "peekOfCode": "def mat2quat(rmat):\n    \"\"\"\n    Converts given rotation matrix to quaternion.\n    Args:\n        rmat (np.array): 3x3 rotation matrix\n    Returns:\n        np.array: (x,y,z,w) float quaternion angles\n    \"\"\"\n    M = np.asarray(rmat).astype(np.float32)[:3, :3]\n    m00 = M[0, 0]",
        "detail": "robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "euler2mat",
        "kind": 2,
        "importPath": "robosuite.utils.transform_utils",
        "description": "robosuite.utils.transform_utils",
        "peekOfCode": "def euler2mat(euler):\n    \"\"\"\n    Converts euler angles into rotation matrix form\n    Args:\n        euler (np.array): (r,p,y) angles\n    Returns:\n        np.array: 3x3 rotation matrix\n    Raises:\n        AssertionError: [Invalid input shape]\n    \"\"\"",
        "detail": "robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "mat2euler",
        "kind": 2,
        "importPath": "robosuite.utils.transform_utils",
        "description": "robosuite.utils.transform_utils",
        "peekOfCode": "def mat2euler(rmat, axes=\"sxyz\"):\n    \"\"\"\n    Converts given rotation matrix to euler angles in radian.\n    Args:\n        rmat (np.array): 3x3 rotation matrix\n        axes (str): One of 24 axis sequences as string or encoded tuple (see top of this module)\n    Returns:\n        np.array: (r,p,y) converted euler angles in radian vec3 float\n    \"\"\"\n    try:",
        "detail": "robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "pose2mat",
        "kind": 2,
        "importPath": "robosuite.utils.transform_utils",
        "description": "robosuite.utils.transform_utils",
        "peekOfCode": "def pose2mat(pose):\n    \"\"\"\n    Converts pose to homogeneous matrix.\n    Args:\n        pose (2-tuple): a (pos, orn) tuple where pos is vec3 float cartesian, and\n            orn is vec4 float quaternion.\n    Returns:\n        np.array: 4x4 homogeneous matrix\n    \"\"\"\n    homo_pose_mat = np.zeros((4, 4), dtype=np.float32)",
        "detail": "robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "quat2mat",
        "kind": 2,
        "importPath": "robosuite.utils.transform_utils",
        "description": "robosuite.utils.transform_utils",
        "peekOfCode": "def quat2mat(quaternion):\n    \"\"\"\n    Converts given quaternion to matrix.\n    Args:\n        quaternion (np.array): (x,y,z,w) vec4 float angles\n    Returns:\n        np.array: 3x3 rotation matrix\n    \"\"\"\n    # awkward semantics for use with numba\n    inds = np.array([3, 0, 1, 2])",
        "detail": "robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "quat2axisangle",
        "kind": 2,
        "importPath": "robosuite.utils.transform_utils",
        "description": "robosuite.utils.transform_utils",
        "peekOfCode": "def quat2axisangle(quat):\n    \"\"\"\n    Converts quaternion to axis-angle format.\n    Returns a unit vector direction scaled by its angle in radians.\n    Args:\n        quat (np.array): (x,y,z,w) vec4 float angles\n    Returns:\n        np.array: (ax,ay,az) axis-angle exponential coordinates\n    \"\"\"\n    # clip quaternion",
        "detail": "robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "quat2euler",
        "kind": 2,
        "importPath": "robosuite.utils.transform_utils",
        "description": "robosuite.utils.transform_utils",
        "peekOfCode": "def quat2euler(quat):\n    \"\"\"\n    Convert a quaternion into euler angles (roll, pitch, yaw)\n    roll is rotation around x in radians (counterclockwise)\n    pitch is rotation around y in radians (counterclockwise)\n    yaw is rotation around z in radians (counterclockwise)\n    Taken from:\n    https://automaticaddison.com/how-to-convert-a-quaternion-into-euler-angles-in-python/\n    \"\"\"\n    x, y, z, w = quat",
        "detail": "robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "axisangle2quat",
        "kind": 2,
        "importPath": "robosuite.utils.transform_utils",
        "description": "robosuite.utils.transform_utils",
        "peekOfCode": "def axisangle2quat(vec):\n    \"\"\"\n    Converts scaled axis-angle to quat.\n    Args:\n        vec (np.array): (ax,ay,az) axis-angle exponential coordinates\n    Returns:\n        np.array: (x,y,z,w) vec4 float angles\n    \"\"\"\n    # Grab angle\n    angle = np.linalg.norm(vec)",
        "detail": "robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "pose_in_A_to_pose_in_B",
        "kind": 2,
        "importPath": "robosuite.utils.transform_utils",
        "description": "robosuite.utils.transform_utils",
        "peekOfCode": "def pose_in_A_to_pose_in_B(pose_A, pose_A_in_B):\n    \"\"\"\n    Converts a homogenous matrix corresponding to a point C in frame A\n    to a homogenous matrix corresponding to the same point C in frame B.\n    Args:\n        pose_A (np.array): 4x4 matrix corresponding to the pose of C in frame A\n        pose_A_in_B (np.array): 4x4 matrix corresponding to the pose of A in frame B\n    Returns:\n        np.array: 4x4 matrix corresponding to the pose of C in frame B\n    \"\"\"",
        "detail": "robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "pose_inv",
        "kind": 2,
        "importPath": "robosuite.utils.transform_utils",
        "description": "robosuite.utils.transform_utils",
        "peekOfCode": "def pose_inv(pose):\n    \"\"\"\n    Computes the inverse of a homogeneous matrix corresponding to the pose of some\n    frame B in frame A. The inverse is the pose of frame A in frame B.\n    Args:\n        pose (np.array): 4x4 matrix for the pose to inverse\n    Returns:\n        np.array: 4x4 matrix for the inverse pose\n    \"\"\"\n    # Note, the inverse of a pose matrix is the following",
        "detail": "robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "vel_in_A_to_vel_in_B",
        "kind": 2,
        "importPath": "robosuite.utils.transform_utils",
        "description": "robosuite.utils.transform_utils",
        "peekOfCode": "def vel_in_A_to_vel_in_B(vel_A, ang_vel_A, pose_A_in_B):\n    \"\"\"\n    Converts linear and angular velocity of a point in frame A to the equivalent in frame B.\n    Args:\n        vel_A (np.array): (vx,vy,vz) linear velocity in A\n        ang_vel_A (np.array): (wx,wy,wz) angular velocity in A\n        pose_A_in_B (np.array): 4x4 matrix corresponding to the pose of A in frame B\n    Returns:\n        2-tuple:\n            - (np.array) (vx,vy,vz) linear velocities in frame B",
        "detail": "robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "force_in_A_to_force_in_B",
        "kind": 2,
        "importPath": "robosuite.utils.transform_utils",
        "description": "robosuite.utils.transform_utils",
        "peekOfCode": "def force_in_A_to_force_in_B(force_A, torque_A, pose_A_in_B):\n    \"\"\"\n    Converts linear and rotational force at a point in frame A to the equivalent in frame B.\n    Args:\n        force_A (np.array): (fx,fy,fz) linear force in A\n        torque_A (np.array): (tx,ty,tz) rotational force (moment) in A\n        pose_A_in_B (np.array): 4x4 matrix corresponding to the pose of A in frame B\n    Returns:\n        2-tuple:\n            - (np.array) (fx,fy,fz) linear forces in frame B",
        "detail": "robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "rotation_matrix",
        "kind": 2,
        "importPath": "robosuite.utils.transform_utils",
        "description": "robosuite.utils.transform_utils",
        "peekOfCode": "def rotation_matrix(angle, direction, point=None):\n    \"\"\"\n    Returns matrix to rotate about axis defined by point and direction.\n    E.g.:\n        >>> angle = (random.random() - 0.5) * (2*math.pi)\n        >>> direc = numpy.random.random(3) - 0.5\n        >>> point = numpy.random.random(3) - 0.5\n        >>> R0 = rotation_matrix(angle, direc, point)\n        >>> R1 = rotation_matrix(angle-2*math.pi, direc, point)\n        >>> is_same_transform(R0, R1)",
        "detail": "robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "clip_translation",
        "kind": 2,
        "importPath": "robosuite.utils.transform_utils",
        "description": "robosuite.utils.transform_utils",
        "peekOfCode": "def clip_translation(dpos, limit):\n    \"\"\"\n    Limits a translation (delta position) to a specified limit\n    Scales down the norm of the dpos to 'limit' if norm(dpos) > limit, else returns immediately\n    Args:\n        dpos (n-array): n-dim Translation being clipped (e,g.: (x, y, z)) -- numpy array\n        limit (float): Value to limit translation by -- magnitude (scalar, in same units as input)\n    Returns:\n        2-tuple:\n            - (np.array) Clipped translation (same dimension as inputs)",
        "detail": "robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "clip_rotation",
        "kind": 2,
        "importPath": "robosuite.utils.transform_utils",
        "description": "robosuite.utils.transform_utils",
        "peekOfCode": "def clip_rotation(quat, limit):\n    \"\"\"\n    Limits a (delta) rotation to a specified limit\n    Converts rotation to axis-angle, clips, then re-converts back into quaternion\n    Args:\n        quat (np.array): (x,y,z,w) rotation being clipped\n        limit (float): Value to limit rotation by -- magnitude (scalar, in radians)\n    Returns:\n        2-tuple:\n            - (np.array) Clipped rotation quaternion (x, y, z, w)",
        "detail": "robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "make_pose",
        "kind": 2,
        "importPath": "robosuite.utils.transform_utils",
        "description": "robosuite.utils.transform_utils",
        "peekOfCode": "def make_pose(translation, rotation):\n    \"\"\"\n    Makes a homogeneous pose matrix from a translation vector and a rotation matrix.\n    Args:\n        translation (np.array): (x,y,z) translation value\n        rotation (np.array): a 3x3 matrix representing rotation\n    Returns:\n        pose (np.array): a 4x4 homogeneous matrix\n    \"\"\"\n    pose = np.zeros((4, 4))",
        "detail": "robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "unit_vector",
        "kind": 2,
        "importPath": "robosuite.utils.transform_utils",
        "description": "robosuite.utils.transform_utils",
        "peekOfCode": "def unit_vector(data, axis=None, out=None):\n    \"\"\"\n    Returns ndarray normalized by length, i.e. eucledian norm, along axis.\n    E.g.:\n        >>> v0 = numpy.random.random(3)\n        >>> v1 = unit_vector(v0)\n        >>> numpy.allclose(v1, v0 / numpy.linalg.norm(v0))\n        True\n        >>> v0 = numpy.random.rand(5, 4, 3)\n        >>> v1 = unit_vector(v0, axis=-1)",
        "detail": "robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "get_orientation_error",
        "kind": 2,
        "importPath": "robosuite.utils.transform_utils",
        "description": "robosuite.utils.transform_utils",
        "peekOfCode": "def get_orientation_error(target_orn, current_orn):\n    \"\"\"\n    Returns the difference between two quaternion orientations as a 3 DOF numpy array.\n    For use in an impedance controller / task-space PD controller.\n    Args:\n        target_orn (np.array): (x, y, z, w) desired quaternion orientation\n        current_orn (np.array): (x, y, z, w) current quaternion orientation\n    Returns:\n        orn_error (np.array): (ax,ay,az) current orientation error, corresponds to\n            (target_orn - current_orn)",
        "detail": "robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "get_pose_error",
        "kind": 2,
        "importPath": "robosuite.utils.transform_utils",
        "description": "robosuite.utils.transform_utils",
        "peekOfCode": "def get_pose_error(target_pose, current_pose):\n    \"\"\"\n    Computes the error corresponding to target pose - current pose as a 6-dim vector.\n    The first 3 components correspond to translational error while the last 3 components\n    correspond to the rotational error.\n    Args:\n        target_pose (np.array): a 4x4 homogenous matrix for the target pose\n        current_pose (np.array): a 4x4 homogenous matrix for the current pose\n    Returns:\n        np.array: 6-dim pose error.",
        "detail": "robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "matrix_inverse",
        "kind": 2,
        "importPath": "robosuite.utils.transform_utils",
        "description": "robosuite.utils.transform_utils",
        "peekOfCode": "def matrix_inverse(matrix):\n    \"\"\"\n    Helper function to have an efficient matrix inversion function.\n    Args:\n        matrix (np.array): 2d-array representing a matrix\n    Returns:\n        np.array: 2d-array representing the matrix inverse\n    \"\"\"\n    return np.linalg.inv(matrix)",
        "detail": "robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "PI",
        "kind": 5,
        "importPath": "robosuite.utils.transform_utils",
        "description": "robosuite.utils.transform_utils",
        "peekOfCode": "PI = np.pi\nEPS = np.finfo(float).eps * 4.\n# axis sequences for Euler angles\n_NEXT_AXIS = [1, 2, 0, 1]\n# map axes strings to/from tuples of inner axis, parity, repetition, frame\n_AXES2TUPLE = {\n    \"sxyz\": (0, 0, 0, 0),\n    \"sxyx\": (0, 0, 1, 0),\n    \"sxzy\": (0, 1, 0, 0),\n    \"sxzx\": (0, 1, 1, 0),",
        "detail": "robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "EPS",
        "kind": 5,
        "importPath": "robosuite.utils.transform_utils",
        "description": "robosuite.utils.transform_utils",
        "peekOfCode": "EPS = np.finfo(float).eps * 4.\n# axis sequences for Euler angles\n_NEXT_AXIS = [1, 2, 0, 1]\n# map axes strings to/from tuples of inner axis, parity, repetition, frame\n_AXES2TUPLE = {\n    \"sxyz\": (0, 0, 0, 0),\n    \"sxyx\": (0, 0, 1, 0),\n    \"sxzy\": (0, 1, 0, 0),\n    \"sxzx\": (0, 1, 1, 0),\n    \"syzx\": (1, 0, 0, 0),",
        "detail": "robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "_NEXT_AXIS",
        "kind": 5,
        "importPath": "robosuite.utils.transform_utils",
        "description": "robosuite.utils.transform_utils",
        "peekOfCode": "_NEXT_AXIS = [1, 2, 0, 1]\n# map axes strings to/from tuples of inner axis, parity, repetition, frame\n_AXES2TUPLE = {\n    \"sxyz\": (0, 0, 0, 0),\n    \"sxyx\": (0, 0, 1, 0),\n    \"sxzy\": (0, 1, 0, 0),\n    \"sxzx\": (0, 1, 1, 0),\n    \"syzx\": (1, 0, 0, 0),\n    \"syzy\": (1, 0, 1, 0),\n    \"syxz\": (1, 1, 0, 0),",
        "detail": "robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "_AXES2TUPLE",
        "kind": 5,
        "importPath": "robosuite.utils.transform_utils",
        "description": "robosuite.utils.transform_utils",
        "peekOfCode": "_AXES2TUPLE = {\n    \"sxyz\": (0, 0, 0, 0),\n    \"sxyx\": (0, 0, 1, 0),\n    \"sxzy\": (0, 1, 0, 0),\n    \"sxzx\": (0, 1, 1, 0),\n    \"syzx\": (1, 0, 0, 0),\n    \"syzy\": (1, 0, 1, 0),\n    \"syxz\": (1, 1, 0, 0),\n    \"syxy\": (1, 1, 1, 0),\n    \"szxy\": (2, 0, 0, 0),",
        "detail": "robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "_TUPLE2AXES",
        "kind": 5,
        "importPath": "robosuite.utils.transform_utils",
        "description": "robosuite.utils.transform_utils",
        "peekOfCode": "_TUPLE2AXES = dict((v, k) for k, v in _AXES2TUPLE.items())\ndef convert_quat(q, to=\"xyzw\"):\n    \"\"\"\n    Converts quaternion from one convention to another.\n    The convention to convert TO is specified as an optional argument.\n    If to == 'xyzw', then the input is in 'wxyz' format, and vice-versa.\n    Args:\n        q (np.array): a 4-dim array corresponding to a quaternion\n        to (str): either 'xyzw' or 'wxyz', determining which convention to convert to.\n    \"\"\"",
        "detail": "robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "DataCollectionWrapper",
        "kind": 6,
        "importPath": "robosuite.wrappers.data_collection_wrapper",
        "description": "robosuite.wrappers.data_collection_wrapper",
        "peekOfCode": "class DataCollectionWrapper(Wrapper):\n    def __init__(self, env, directory, collect_freq=1, flush_freq=100):\n        \"\"\"\n        Initializes the data collection wrapper.\n        Args:\n            env (MujocoEnv): The environment to monitor.\n            directory (str): Where to store collected data.\n            collect_freq (int): How often to save simulation state, in terms of environment steps.\n            flush_freq (int): How frequently to dump data to disk, in terms of environment steps.\n        \"\"\"",
        "detail": "robosuite.wrappers.data_collection_wrapper",
        "documentation": {}
    },
    {
        "label": "DemoSamplerWrapper",
        "kind": 6,
        "importPath": "robosuite.wrappers.demo_sampler_wrapper",
        "description": "robosuite.wrappers.demo_sampler_wrapper",
        "peekOfCode": "class DemoSamplerWrapper(Wrapper):\n    \"\"\"\n    Initializes a wrapper that provides support for resetting the environment\n    state to one from a demonstration. It also supports curriculums for\n    altering how often to sample from demonstration vs. sampling a reset\n    state from the environment.\n    Args:\n        env (MujocoEnv): The environment to wrap.\n        demo_path (str): The path to the folder containing the demonstrations.\n            There should be a `demo.hdf5` file and a folder named `models` with",
        "detail": "robosuite.wrappers.demo_sampler_wrapper",
        "documentation": {}
    },
    {
        "label": "DomainRandomizationWrapper",
        "kind": 6,
        "importPath": "robosuite.wrappers.domain_randomization_wrapper",
        "description": "robosuite.wrappers.domain_randomization_wrapper",
        "peekOfCode": "class DomainRandomizationWrapper(Wrapper):\n    \"\"\"\n    Wrapper that allows for domain randomization mid-simulation.\n    Args:\n        env (MujocoEnv): The environment to wrap.\n        seed (int): Integer used to seed all randomizations from this wrapper. It is\n            used to create a np.random.RandomState instance to make sure samples here\n            are isolated from sampling occurring elsewhere in the code. If not provided,\n            will default to using global random state.\n        randomize_color (bool): if True, randomize geom colors and texture colors",
        "detail": "robosuite.wrappers.domain_randomization_wrapper",
        "documentation": {}
    },
    {
        "label": "DEFAULT_COLOR_ARGS",
        "kind": 5,
        "importPath": "robosuite.wrappers.domain_randomization_wrapper",
        "description": "robosuite.wrappers.domain_randomization_wrapper",
        "peekOfCode": "DEFAULT_COLOR_ARGS = {\n    'geom_names' : None, # all geoms are randomized\n    'randomize_local' : True, # sample nearby colors\n    'randomize_material' : True, # randomize material reflectance / shininess / specular\n    'local_rgb_interpolation' : 0.2,\n    'local_material_interpolation' : 0.3,\n    'texture_variations' : ['rgb', 'checker', 'noise', 'gradient'], # all texture variation types\n    'randomize_skybox' : True, # by default, randomize skybox too\n}\nDEFAULT_CAMERA_ARGS = {",
        "detail": "robosuite.wrappers.domain_randomization_wrapper",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CAMERA_ARGS",
        "kind": 5,
        "importPath": "robosuite.wrappers.domain_randomization_wrapper",
        "description": "robosuite.wrappers.domain_randomization_wrapper",
        "peekOfCode": "DEFAULT_CAMERA_ARGS = {\n    'camera_names' : None, # all cameras are randomized\n    'randomize_position' : True,\n    'randomize_rotation' : True,\n    'randomize_fovy' : True,\n    'position_perturbation_size' : 0.01,\n    'rotation_perturbation_size' : 0.087,\n    'fovy_perturbation_size' : 5.,\n}\nDEFAULT_LIGHTING_ARGS = {",
        "detail": "robosuite.wrappers.domain_randomization_wrapper",
        "documentation": {}
    },
    {
        "label": "DEFAULT_LIGHTING_ARGS",
        "kind": 5,
        "importPath": "robosuite.wrappers.domain_randomization_wrapper",
        "description": "robosuite.wrappers.domain_randomization_wrapper",
        "peekOfCode": "DEFAULT_LIGHTING_ARGS = {\n    'light_names' : None, # all lights are randomized\n    'randomize_position' : True,\n    'randomize_direction' : True,\n    'randomize_specular' : True,\n    'randomize_ambient' : True,\n    'randomize_diffuse' : True,\n    'randomize_active' : True,\n    'position_perturbation_size' : 0.1,\n    'direction_perturbation_size' : 0.35,",
        "detail": "robosuite.wrappers.domain_randomization_wrapper",
        "documentation": {}
    },
    {
        "label": "GymWrapper",
        "kind": 6,
        "importPath": "robosuite.wrappers.gym_wrapper",
        "description": "robosuite.wrappers.gym_wrapper",
        "peekOfCode": "class GymWrapper(Wrapper, Env):\n    \"\"\"\n    Initializes the Gym wrapper. Mimics many of the required functionalities of the Wrapper class\n    found in the gym.core module\n    Args:\n        env (MujocoEnv): The environment to wrap.\n        keys (None or list of str): If provided, each observation will\n            consist of concatenated keys from the wrapped environment's\n            observation dictionary. Defaults to robot-state and object-state.\n    Raises:",
        "detail": "robosuite.wrappers.gym_wrapper",
        "documentation": {}
    },
    {
        "label": "VisualizationWrapper",
        "kind": 6,
        "importPath": "robosuite.wrappers.visualization_wrapper",
        "description": "robosuite.wrappers.visualization_wrapper",
        "peekOfCode": "class VisualizationWrapper(Wrapper):\n    def __init__(self, env, indicator_configs=None):\n        \"\"\"\n        Initializes the data collection wrapper. Note that this automatically conducts a (hard) reset initially to make\n        sure indicators are properly added to the sim model.\n        Args:\n            env (MujocoEnv): The environment to visualize\n            indicator_configs (None or str or dict or list): Configurations to use for indicator objects.\n                If None, no indicator objects will be used\n                If a string, this should be `'default'`, which corresponds to single default spherical indicator",
        "detail": "robosuite.wrappers.visualization_wrapper",
        "documentation": {}
    },
    {
        "label": "DEFAULT_INDICATOR_SITE_CONFIG",
        "kind": 5,
        "importPath": "robosuite.wrappers.visualization_wrapper",
        "description": "robosuite.wrappers.visualization_wrapper",
        "peekOfCode": "DEFAULT_INDICATOR_SITE_CONFIG = {\n    \"type\": \"sphere\",\n    \"size\": [0.03],\n    \"rgba\": [1, 0, 0, 0.5],\n}\nclass VisualizationWrapper(Wrapper):\n    def __init__(self, env, indicator_configs=None):\n        \"\"\"\n        Initializes the data collection wrapper. Note that this automatically conducts a (hard) reset initially to make\n        sure indicators are properly added to the sim model.",
        "detail": "robosuite.wrappers.visualization_wrapper",
        "documentation": {}
    },
    {
        "label": "Wrapper",
        "kind": 6,
        "importPath": "robosuite.wrappers.wrapper",
        "description": "robosuite.wrappers.wrapper",
        "peekOfCode": "class Wrapper:\n    \"\"\"\n    Base class for all wrappers in robosuite.\n    Args:\n        env (MujocoEnv): The environment to wrap.\n    \"\"\"\n    def __init__(self, env):\n        self.env = env\n    @classmethod\n    def class_name(cls):",
        "detail": "robosuite.wrappers.wrapper",
        "documentation": {}
    },
    {
        "label": "test_all_controllers",
        "kind": 2,
        "importPath": "tests.test_controllers.test_all_controllers",
        "description": "tests.test_controllers.test_all_controllers",
        "peekOfCode": "def test_all_controllers():\n    for controller_name in controllers.keys():\n        # Define variables for each controller test\n        action_dim = controllers[controller_name][0]\n        num_test_steps = controllers[controller_name][1]\n        test_value = controllers[controller_name][2]\n        neutral = np.zeros(action_dim)\n        # Define controller path to load\n        controller_config = load_controller_config(default_controller=controller_name)\n        # Now, create a test env for testing the controller on",
        "detail": "tests.test_controllers.test_all_controllers",
        "documentation": {}
    },
    {
        "label": "parser",
        "kind": 5,
        "importPath": "tests.test_controllers.test_all_controllers",
        "description": "tests.test_controllers.test_all_controllers",
        "peekOfCode": "parser = argparse.ArgumentParser()\nparser.add_argument(\"--render\", action='store_true', help=\"Whether to render this test or not for visual validation\")\nargs = parser.parse_args()\n# Define the controllers to use (action_dim, num_test_steps, test_value)\ncontrollers = {\n        \"OSC_POSE\":         [7, 6, 0.1],\n        \"OSC_POSITION\":     [4, 3, 0.1],\n        \"IK_POSE\":          [7, 6, 0.01],\n        \"JOINT_POSITION\":   [8, 7, 0.2],\n        \"JOINT_VELOCITY\":   [8, 7, -0.1],",
        "detail": "tests.test_controllers.test_all_controllers",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": "tests.test_controllers.test_all_controllers",
        "description": "tests.test_controllers.test_all_controllers",
        "peekOfCode": "args = parser.parse_args()\n# Define the controllers to use (action_dim, num_test_steps, test_value)\ncontrollers = {\n        \"OSC_POSE\":         [7, 6, 0.1],\n        \"OSC_POSITION\":     [4, 3, 0.1],\n        \"IK_POSE\":          [7, 6, 0.01],\n        \"JOINT_POSITION\":   [8, 7, 0.2],\n        \"JOINT_VELOCITY\":   [8, 7, -0.1],\n        \"JOINT_TORQUE\":     [8, 7, 0.25]\n    }",
        "detail": "tests.test_controllers.test_all_controllers",
        "documentation": {}
    },
    {
        "label": "controllers",
        "kind": 5,
        "importPath": "tests.test_controllers.test_all_controllers",
        "description": "tests.test_controllers.test_all_controllers",
        "peekOfCode": "controllers = {\n        \"OSC_POSE\":         [7, 6, 0.1],\n        \"OSC_POSITION\":     [4, 3, 0.1],\n        \"IK_POSE\":          [7, 6, 0.01],\n        \"JOINT_POSITION\":   [8, 7, 0.2],\n        \"JOINT_VELOCITY\":   [8, 7, -0.1],\n        \"JOINT_TORQUE\":     [8, 7, 0.25]\n    }\n# Define the number of timesteps to use per controller action as well as timesteps in between actions\nsteps_per_action = 50",
        "detail": "tests.test_controllers.test_all_controllers",
        "documentation": {}
    },
    {
        "label": "steps_per_action",
        "kind": 5,
        "importPath": "tests.test_controllers.test_all_controllers",
        "description": "tests.test_controllers.test_all_controllers",
        "peekOfCode": "steps_per_action = 50\nsteps_per_rest = 25\ndef test_all_controllers():\n    for controller_name in controllers.keys():\n        # Define variables for each controller test\n        action_dim = controllers[controller_name][0]\n        num_test_steps = controllers[controller_name][1]\n        test_value = controllers[controller_name][2]\n        neutral = np.zeros(action_dim)\n        # Define controller path to load",
        "detail": "tests.test_controllers.test_all_controllers",
        "documentation": {}
    },
    {
        "label": "steps_per_rest",
        "kind": 5,
        "importPath": "tests.test_controllers.test_all_controllers",
        "description": "tests.test_controllers.test_all_controllers",
        "peekOfCode": "steps_per_rest = 25\ndef test_all_controllers():\n    for controller_name in controllers.keys():\n        # Define variables for each controller test\n        action_dim = controllers[controller_name][0]\n        num_test_steps = controllers[controller_name][1]\n        test_value = controllers[controller_name][2]\n        neutral = np.zeros(action_dim)\n        # Define controller path to load\n        controller_config = load_controller_config(default_controller=controller_name)",
        "detail": "tests.test_controllers.test_all_controllers",
        "documentation": {}
    },
    {
        "label": "step",
        "kind": 2,
        "importPath": "tests.test_controllers.test_linear_interpolator",
        "description": "tests.test_controllers.test_linear_interpolator",
        "peekOfCode": "def step(env, action, current_torques):\n    env.timestep += 1\n    policy_step = True\n    summed_abs_delta_torques = np.zeros(7)\n    for i in range(int(env.control_timestep / env.model_timestep)):\n        env.sim.forward()\n        env._pre_action(action, policy_step)\n        last_torques = current_torques\n        current_torques = env.robots[0].torques\n        summed_abs_delta_torques += np.abs(current_torques - last_torques)",
        "detail": "tests.test_controllers.test_linear_interpolator",
        "documentation": {}
    },
    {
        "label": "test_linear_interpolator",
        "kind": 2,
        "importPath": "tests.test_controllers.test_linear_interpolator",
        "description": "tests.test_controllers.test_linear_interpolator",
        "peekOfCode": "def test_linear_interpolator():\n    for controller_name in [\"IK_POSE\", \"OSC_POSE\"]:\n        for traj in [\"pos\", \"ori\"]:\n            # Define counter to increment timesteps and torques for each trajectory\n            timesteps = [0, 0]\n            summed_abs_delta_torques = [np.zeros(7), np.zeros(7)]\n            for interpolator in [None, \"linear\"]:\n                # Define numpy seed so we guarantee consistent starting pos / ori for each trajectory\n                np.random.seed(3)\n                # Define controller path to load",
        "detail": "tests.test_controllers.test_linear_interpolator",
        "documentation": {}
    },
    {
        "label": "pos_y_threshold",
        "kind": 5,
        "importPath": "tests.test_controllers.test_linear_interpolator",
        "description": "tests.test_controllers.test_linear_interpolator",
        "peekOfCode": "pos_y_threshold = 0.1\ndelta_pos_y = 0.01\npos_action_osc = [0, delta_pos_y * 40, 0]\npos_action_ik = [0, delta_pos_y, 0]\n# Rotation trajectory\nrot_r_threshold = np.pi / 2\ndelta_rot_r = 0.01\nrot_action_osc = [delta_rot_r * 40, 0, 0]\nrot_action_ik = [delta_rot_r * 5, 0, 0]\n# Concatenated thresholds and corresponding indexes (y = 1 in x,y,z; roll = 0 in r,p,y)",
        "detail": "tests.test_controllers.test_linear_interpolator",
        "documentation": {}
    },
    {
        "label": "delta_pos_y",
        "kind": 5,
        "importPath": "tests.test_controllers.test_linear_interpolator",
        "description": "tests.test_controllers.test_linear_interpolator",
        "peekOfCode": "delta_pos_y = 0.01\npos_action_osc = [0, delta_pos_y * 40, 0]\npos_action_ik = [0, delta_pos_y, 0]\n# Rotation trajectory\nrot_r_threshold = np.pi / 2\ndelta_rot_r = 0.01\nrot_action_osc = [delta_rot_r * 40, 0, 0]\nrot_action_ik = [delta_rot_r * 5, 0, 0]\n# Concatenated thresholds and corresponding indexes (y = 1 in x,y,z; roll = 0 in r,p,y)\nthresholds = [pos_y_threshold, rot_r_threshold]",
        "detail": "tests.test_controllers.test_linear_interpolator",
        "documentation": {}
    },
    {
        "label": "pos_action_osc",
        "kind": 5,
        "importPath": "tests.test_controllers.test_linear_interpolator",
        "description": "tests.test_controllers.test_linear_interpolator",
        "peekOfCode": "pos_action_osc = [0, delta_pos_y * 40, 0]\npos_action_ik = [0, delta_pos_y, 0]\n# Rotation trajectory\nrot_r_threshold = np.pi / 2\ndelta_rot_r = 0.01\nrot_action_osc = [delta_rot_r * 40, 0, 0]\nrot_action_ik = [delta_rot_r * 5, 0, 0]\n# Concatenated thresholds and corresponding indexes (y = 1 in x,y,z; roll = 0 in r,p,y)\nthresholds = [pos_y_threshold, rot_r_threshold]\nindexes = [1, 0]",
        "detail": "tests.test_controllers.test_linear_interpolator",
        "documentation": {}
    },
    {
        "label": "pos_action_ik",
        "kind": 5,
        "importPath": "tests.test_controllers.test_linear_interpolator",
        "description": "tests.test_controllers.test_linear_interpolator",
        "peekOfCode": "pos_action_ik = [0, delta_pos_y, 0]\n# Rotation trajectory\nrot_r_threshold = np.pi / 2\ndelta_rot_r = 0.01\nrot_action_osc = [delta_rot_r * 40, 0, 0]\nrot_action_ik = [delta_rot_r * 5, 0, 0]\n# Concatenated thresholds and corresponding indexes (y = 1 in x,y,z; roll = 0 in r,p,y)\nthresholds = [pos_y_threshold, rot_r_threshold]\nindexes = [1, 0]\n# Threshold ratio",
        "detail": "tests.test_controllers.test_linear_interpolator",
        "documentation": {}
    },
    {
        "label": "rot_r_threshold",
        "kind": 5,
        "importPath": "tests.test_controllers.test_linear_interpolator",
        "description": "tests.test_controllers.test_linear_interpolator",
        "peekOfCode": "rot_r_threshold = np.pi / 2\ndelta_rot_r = 0.01\nrot_action_osc = [delta_rot_r * 40, 0, 0]\nrot_action_ik = [delta_rot_r * 5, 0, 0]\n# Concatenated thresholds and corresponding indexes (y = 1 in x,y,z; roll = 0 in r,p,y)\nthresholds = [pos_y_threshold, rot_r_threshold]\nindexes = [1, 0]\n# Threshold ratio\nmin_ratio = 1.10\n# Define arguments for this test",
        "detail": "tests.test_controllers.test_linear_interpolator",
        "documentation": {}
    },
    {
        "label": "delta_rot_r",
        "kind": 5,
        "importPath": "tests.test_controllers.test_linear_interpolator",
        "description": "tests.test_controllers.test_linear_interpolator",
        "peekOfCode": "delta_rot_r = 0.01\nrot_action_osc = [delta_rot_r * 40, 0, 0]\nrot_action_ik = [delta_rot_r * 5, 0, 0]\n# Concatenated thresholds and corresponding indexes (y = 1 in x,y,z; roll = 0 in r,p,y)\nthresholds = [pos_y_threshold, rot_r_threshold]\nindexes = [1, 0]\n# Threshold ratio\nmin_ratio = 1.10\n# Define arguments for this test\nparser = argparse.ArgumentParser()",
        "detail": "tests.test_controllers.test_linear_interpolator",
        "documentation": {}
    },
    {
        "label": "rot_action_osc",
        "kind": 5,
        "importPath": "tests.test_controllers.test_linear_interpolator",
        "description": "tests.test_controllers.test_linear_interpolator",
        "peekOfCode": "rot_action_osc = [delta_rot_r * 40, 0, 0]\nrot_action_ik = [delta_rot_r * 5, 0, 0]\n# Concatenated thresholds and corresponding indexes (y = 1 in x,y,z; roll = 0 in r,p,y)\nthresholds = [pos_y_threshold, rot_r_threshold]\nindexes = [1, 0]\n# Threshold ratio\nmin_ratio = 1.10\n# Define arguments for this test\nparser = argparse.ArgumentParser()\nparser.add_argument(\"--render\", action=\"store_true\", help=\"Whether to render tests or run headless\")",
        "detail": "tests.test_controllers.test_linear_interpolator",
        "documentation": {}
    },
    {
        "label": "rot_action_ik",
        "kind": 5,
        "importPath": "tests.test_controllers.test_linear_interpolator",
        "description": "tests.test_controllers.test_linear_interpolator",
        "peekOfCode": "rot_action_ik = [delta_rot_r * 5, 0, 0]\n# Concatenated thresholds and corresponding indexes (y = 1 in x,y,z; roll = 0 in r,p,y)\nthresholds = [pos_y_threshold, rot_r_threshold]\nindexes = [1, 0]\n# Threshold ratio\nmin_ratio = 1.10\n# Define arguments for this test\nparser = argparse.ArgumentParser()\nparser.add_argument(\"--render\", action=\"store_true\", help=\"Whether to render tests or run headless\")\nargs = parser.parse_args()",
        "detail": "tests.test_controllers.test_linear_interpolator",
        "documentation": {}
    },
    {
        "label": "thresholds",
        "kind": 5,
        "importPath": "tests.test_controllers.test_linear_interpolator",
        "description": "tests.test_controllers.test_linear_interpolator",
        "peekOfCode": "thresholds = [pos_y_threshold, rot_r_threshold]\nindexes = [1, 0]\n# Threshold ratio\nmin_ratio = 1.10\n# Define arguments for this test\nparser = argparse.ArgumentParser()\nparser.add_argument(\"--render\", action=\"store_true\", help=\"Whether to render tests or run headless\")\nargs = parser.parse_args()\n# Setup printing options for numbers\nnp.set_printoptions(formatter={'float': lambda x: \"{0:0.3f}\".format(x)})",
        "detail": "tests.test_controllers.test_linear_interpolator",
        "documentation": {}
    },
    {
        "label": "indexes",
        "kind": 5,
        "importPath": "tests.test_controllers.test_linear_interpolator",
        "description": "tests.test_controllers.test_linear_interpolator",
        "peekOfCode": "indexes = [1, 0]\n# Threshold ratio\nmin_ratio = 1.10\n# Define arguments for this test\nparser = argparse.ArgumentParser()\nparser.add_argument(\"--render\", action=\"store_true\", help=\"Whether to render tests or run headless\")\nargs = parser.parse_args()\n# Setup printing options for numbers\nnp.set_printoptions(formatter={'float': lambda x: \"{0:0.3f}\".format(x)})\n# function to run the actual sim in order to receive summed absolute delta torques",
        "detail": "tests.test_controllers.test_linear_interpolator",
        "documentation": {}
    },
    {
        "label": "min_ratio",
        "kind": 5,
        "importPath": "tests.test_controllers.test_linear_interpolator",
        "description": "tests.test_controllers.test_linear_interpolator",
        "peekOfCode": "min_ratio = 1.10\n# Define arguments for this test\nparser = argparse.ArgumentParser()\nparser.add_argument(\"--render\", action=\"store_true\", help=\"Whether to render tests or run headless\")\nargs = parser.parse_args()\n# Setup printing options for numbers\nnp.set_printoptions(formatter={'float': lambda x: \"{0:0.3f}\".format(x)})\n# function to run the actual sim in order to receive summed absolute delta torques\ndef step(env, action, current_torques):\n    env.timestep += 1",
        "detail": "tests.test_controllers.test_linear_interpolator",
        "documentation": {}
    },
    {
        "label": "parser",
        "kind": 5,
        "importPath": "tests.test_controllers.test_linear_interpolator",
        "description": "tests.test_controllers.test_linear_interpolator",
        "peekOfCode": "parser = argparse.ArgumentParser()\nparser.add_argument(\"--render\", action=\"store_true\", help=\"Whether to render tests or run headless\")\nargs = parser.parse_args()\n# Setup printing options for numbers\nnp.set_printoptions(formatter={'float': lambda x: \"{0:0.3f}\".format(x)})\n# function to run the actual sim in order to receive summed absolute delta torques\ndef step(env, action, current_torques):\n    env.timestep += 1\n    policy_step = True\n    summed_abs_delta_torques = np.zeros(7)",
        "detail": "tests.test_controllers.test_linear_interpolator",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": "tests.test_controllers.test_linear_interpolator",
        "description": "tests.test_controllers.test_linear_interpolator",
        "peekOfCode": "args = parser.parse_args()\n# Setup printing options for numbers\nnp.set_printoptions(formatter={'float': lambda x: \"{0:0.3f}\".format(x)})\n# function to run the actual sim in order to receive summed absolute delta torques\ndef step(env, action, current_torques):\n    env.timestep += 1\n    policy_step = True\n    summed_abs_delta_torques = np.zeros(7)\n    for i in range(int(env.control_timestep / env.model_timestep)):\n        env.sim.forward()",
        "detail": "tests.test_controllers.test_linear_interpolator",
        "documentation": {}
    },
    {
        "label": "test_variable_impedance",
        "kind": 2,
        "importPath": "tests.test_controllers.test_variable_impedance",
        "description": "tests.test_controllers.test_variable_impedance",
        "peekOfCode": "def test_variable_impedance():\n    for controller_name in [\"OSC_POSE\", \"OSC_POSITION\", \"JOINT_POSITION\"]:\n        # Define numpy seed so we guarantee consistent starting pos / ori for each trajectory\n        np.random.seed(3)\n        # Define controller path to load\n        controller_path = os.path.join(os.path.dirname(__file__),\n                                       '../../robosuite',\n                                       'controllers/config/{}.json'.format(controller_name.lower()))\n        # Load the controller\n        with open(controller_path) as f:",
        "detail": "tests.test_controllers.test_variable_impedance",
        "documentation": {}
    },
    {
        "label": "num_timesteps_per_change",
        "kind": 5,
        "importPath": "tests.test_controllers.test_variable_impedance",
        "description": "tests.test_controllers.test_variable_impedance",
        "peekOfCode": "num_timesteps_per_change = 10\npercent_increase = 0.05\n# Define delta values for trajectory\nd = 0.05\n# Define default values for fixing one of the two gains\nkp_default = 150\ndamping_default = 1     # critically damped\n# Define arguments for this test\nparser = argparse.ArgumentParser()\nparser.add_argument(\"--render\", action=\"store_true\", help=\"Whether to render tests or run headless\")",
        "detail": "tests.test_controllers.test_variable_impedance",
        "documentation": {}
    },
    {
        "label": "percent_increase",
        "kind": 5,
        "importPath": "tests.test_controllers.test_variable_impedance",
        "description": "tests.test_controllers.test_variable_impedance",
        "peekOfCode": "percent_increase = 0.05\n# Define delta values for trajectory\nd = 0.05\n# Define default values for fixing one of the two gains\nkp_default = 150\ndamping_default = 1     # critically damped\n# Define arguments for this test\nparser = argparse.ArgumentParser()\nparser.add_argument(\"--render\", action=\"store_true\", help=\"Whether to render tests or run headless\")\nargs = parser.parse_args()",
        "detail": "tests.test_controllers.test_variable_impedance",
        "documentation": {}
    },
    {
        "label": "d",
        "kind": 5,
        "importPath": "tests.test_controllers.test_variable_impedance",
        "description": "tests.test_controllers.test_variable_impedance",
        "peekOfCode": "d = 0.05\n# Define default values for fixing one of the two gains\nkp_default = 150\ndamping_default = 1     # critically damped\n# Define arguments for this test\nparser = argparse.ArgumentParser()\nparser.add_argument(\"--render\", action=\"store_true\", help=\"Whether to render tests or run headless\")\nargs = parser.parse_args()\n# Running the actual test #\ndef test_variable_impedance():",
        "detail": "tests.test_controllers.test_variable_impedance",
        "documentation": {}
    },
    {
        "label": "kp_default",
        "kind": 5,
        "importPath": "tests.test_controllers.test_variable_impedance",
        "description": "tests.test_controllers.test_variable_impedance",
        "peekOfCode": "kp_default = 150\ndamping_default = 1     # critically damped\n# Define arguments for this test\nparser = argparse.ArgumentParser()\nparser.add_argument(\"--render\", action=\"store_true\", help=\"Whether to render tests or run headless\")\nargs = parser.parse_args()\n# Running the actual test #\ndef test_variable_impedance():\n    for controller_name in [\"OSC_POSE\", \"OSC_POSITION\", \"JOINT_POSITION\"]:\n        # Define numpy seed so we guarantee consistent starting pos / ori for each trajectory",
        "detail": "tests.test_controllers.test_variable_impedance",
        "documentation": {}
    },
    {
        "label": "damping_default",
        "kind": 5,
        "importPath": "tests.test_controllers.test_variable_impedance",
        "description": "tests.test_controllers.test_variable_impedance",
        "peekOfCode": "damping_default = 1     # critically damped\n# Define arguments for this test\nparser = argparse.ArgumentParser()\nparser.add_argument(\"--render\", action=\"store_true\", help=\"Whether to render tests or run headless\")\nargs = parser.parse_args()\n# Running the actual test #\ndef test_variable_impedance():\n    for controller_name in [\"OSC_POSE\", \"OSC_POSITION\", \"JOINT_POSITION\"]:\n        # Define numpy seed so we guarantee consistent starting pos / ori for each trajectory\n        np.random.seed(3)",
        "detail": "tests.test_controllers.test_variable_impedance",
        "documentation": {}
    },
    {
        "label": "parser",
        "kind": 5,
        "importPath": "tests.test_controllers.test_variable_impedance",
        "description": "tests.test_controllers.test_variable_impedance",
        "peekOfCode": "parser = argparse.ArgumentParser()\nparser.add_argument(\"--render\", action=\"store_true\", help=\"Whether to render tests or run headless\")\nargs = parser.parse_args()\n# Running the actual test #\ndef test_variable_impedance():\n    for controller_name in [\"OSC_POSE\", \"OSC_POSITION\", \"JOINT_POSITION\"]:\n        # Define numpy seed so we guarantee consistent starting pos / ori for each trajectory\n        np.random.seed(3)\n        # Define controller path to load\n        controller_path = os.path.join(os.path.dirname(__file__),",
        "detail": "tests.test_controllers.test_variable_impedance",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": "tests.test_controllers.test_variable_impedance",
        "description": "tests.test_controllers.test_variable_impedance",
        "peekOfCode": "args = parser.parse_args()\n# Running the actual test #\ndef test_variable_impedance():\n    for controller_name in [\"OSC_POSE\", \"OSC_POSITION\", \"JOINT_POSITION\"]:\n        # Define numpy seed so we guarantee consistent starting pos / ori for each trajectory\n        np.random.seed(3)\n        # Define controller path to load\n        controller_path = os.path.join(os.path.dirname(__file__),\n                                       '../../robosuite',\n                                       'controllers/config/{}.json'.format(controller_name.lower()))",
        "detail": "tests.test_controllers.test_variable_impedance",
        "documentation": {}
    },
    {
        "label": "test_all_environments",
        "kind": 2,
        "importPath": "tests.test_environments.test_all_environments",
        "description": "tests.test_environments.test_all_environments",
        "peekOfCode": "def test_all_environments():\n    envs = sorted(suite.ALL_ENVIRONMENTS)\n    for env_name in envs:\n        # Create config dict\n        env_config = {\"env_name\": env_name}\n        for robot_name in (\"Panda\", \"Sawyer\", \"Baxter\"):\n            # create an environment for learning on pixels\n            config = None\n            if \"TwoArm\" in env_name:\n                if robot_name == \"Baxter\":",
        "detail": "tests.test_environments.test_all_environments",
        "documentation": {}
    },
    {
        "label": "test_all_gripper",
        "kind": 2,
        "importPath": "tests.test_grippers.test_all_grippers",
        "description": "tests.test_grippers.test_all_grippers",
        "peekOfCode": "def test_all_gripper():\n    for name, gripper in GRIPPER_MAPPING.items():\n        # Test all grippers except the null gripper\n        if name not in {None, \"WipingGripper\"}:\n            print(\"Testing {}...\".format(name))\n            _test_gripper(gripper())\ndef _test_gripper(gripper):\n    action = gripper.format_action([1] * gripper.dof)\n    assert action is not None\n    assert gripper.init_qpos is not None",
        "detail": "tests.test_grippers.test_all_grippers",
        "documentation": {}
    },
    {
        "label": "test_robotiq",
        "kind": 2,
        "importPath": "tests.test_grippers.test_jaco_threefinger",
        "description": "tests.test_grippers.test_jaco_threefinger",
        "peekOfCode": "def test_robotiq():\n    robotiq_tester(False)\ndef robotiq_tester(render,\n                   total_iters=1,\n                   test_y=True):\n    gripper = JacoThreeFingerGripper()\n    tester = GripperTester(\n        gripper=gripper,\n        pos=\"0 0 0.3\",\n        quat=\"0 0 1 0\",",
        "detail": "tests.test_grippers.test_jaco_threefinger",
        "documentation": {}
    },
    {
        "label": "robotiq_tester",
        "kind": 2,
        "importPath": "tests.test_grippers.test_jaco_threefinger",
        "description": "tests.test_grippers.test_jaco_threefinger",
        "peekOfCode": "def robotiq_tester(render,\n                   total_iters=1,\n                   test_y=True):\n    gripper = JacoThreeFingerGripper()\n    tester = GripperTester(\n        gripper=gripper,\n        pos=\"0 0 0.3\",\n        quat=\"0 0 1 0\",\n        gripper_low_pos=0.01,\n        gripper_high_pos=0.1,",
        "detail": "tests.test_grippers.test_jaco_threefinger",
        "documentation": {}
    },
    {
        "label": "test_panda_gripper",
        "kind": 2,
        "importPath": "tests.test_grippers.test_panda_gripper",
        "description": "tests.test_grippers.test_panda_gripper",
        "peekOfCode": "def test_panda_gripper():\n    panda_gripper_tester(False)\ndef panda_gripper_tester(render,\n                      total_iters=1,\n                      test_y=True):\n    gripper = PandaGripper()\n    tester = GripperTester(\n        gripper=gripper,\n        pos=\"0 0 0.3\",\n        quat=\"0 0 1 0\",",
        "detail": "tests.test_grippers.test_panda_gripper",
        "documentation": {}
    },
    {
        "label": "panda_gripper_tester",
        "kind": 2,
        "importPath": "tests.test_grippers.test_panda_gripper",
        "description": "tests.test_grippers.test_panda_gripper",
        "peekOfCode": "def panda_gripper_tester(render,\n                      total_iters=1,\n                      test_y=True):\n    gripper = PandaGripper()\n    tester = GripperTester(\n        gripper=gripper,\n        pos=\"0 0 0.3\",\n        quat=\"0 0 1 0\",\n        gripper_low_pos=-0.10,\n        gripper_high_pos=0.01,",
        "detail": "tests.test_grippers.test_panda_gripper",
        "documentation": {}
    },
    {
        "label": "test_two_finger",
        "kind": 2,
        "importPath": "tests.test_grippers.test_rethink_gripper",
        "description": "tests.test_grippers.test_rethink_gripper",
        "peekOfCode": "def test_two_finger():\n    two_finger_tester(False)\ndef two_finger_tester(render,\n                      total_iters=1,\n                      test_y=True):\n    gripper = RethinkGripper()\n    tester = GripperTester(\n        gripper=gripper,\n        pos=\"0 0 0.3\",\n        quat=\"0 0 1 0\",",
        "detail": "tests.test_grippers.test_rethink_gripper",
        "documentation": {}
    },
    {
        "label": "two_finger_tester",
        "kind": 2,
        "importPath": "tests.test_grippers.test_rethink_gripper",
        "description": "tests.test_grippers.test_rethink_gripper",
        "peekOfCode": "def two_finger_tester(render,\n                      total_iters=1,\n                      test_y=True):\n    gripper = RethinkGripper()\n    tester = GripperTester(\n        gripper=gripper,\n        pos=\"0 0 0.3\",\n        quat=\"0 0 1 0\",\n        gripper_low_pos=-0.07,\n        gripper_high_pos=0.02,",
        "detail": "tests.test_grippers.test_rethink_gripper",
        "documentation": {}
    },
    {
        "label": "test_robotiq",
        "kind": 2,
        "importPath": "tests.test_grippers.test_robotiq_140",
        "description": "tests.test_grippers.test_robotiq_140",
        "peekOfCode": "def test_robotiq():\n    robotiq_tester(False)\ndef robotiq_tester(render,\n                   total_iters=1,\n                   test_y=True):\n    gripper = Robotiq140Gripper()\n    tester = GripperTester(\n        gripper=gripper,\n        pos=\"0 0 0.3\",\n        quat=\"0 0 1 0\",",
        "detail": "tests.test_grippers.test_robotiq_140",
        "documentation": {}
    },
    {
        "label": "robotiq_tester",
        "kind": 2,
        "importPath": "tests.test_grippers.test_robotiq_140",
        "description": "tests.test_grippers.test_robotiq_140",
        "peekOfCode": "def robotiq_tester(render,\n                   total_iters=1,\n                   test_y=True):\n    gripper = Robotiq140Gripper()\n    tester = GripperTester(\n        gripper=gripper,\n        pos=\"0 0 0.3\",\n        quat=\"0 0 1 0\",\n        gripper_low_pos=0.02,\n        gripper_high_pos=0.1,",
        "detail": "tests.test_grippers.test_robotiq_140",
        "documentation": {}
    },
    {
        "label": "test_robotiq",
        "kind": 2,
        "importPath": "tests.test_grippers.test_robotiq_85",
        "description": "tests.test_grippers.test_robotiq_85",
        "peekOfCode": "def test_robotiq():\n    robotiq_tester(False)\ndef robotiq_tester(render,\n                   total_iters=1,\n                   test_y=True):\n    gripper = Robotiq85Gripper()\n    tester = GripperTester(\n        gripper=gripper,\n        pos=\"-0.02 0 0.3\",\n        quat=\"0 0 1 0\",",
        "detail": "tests.test_grippers.test_robotiq_85",
        "documentation": {}
    },
    {
        "label": "robotiq_tester",
        "kind": 2,
        "importPath": "tests.test_grippers.test_robotiq_85",
        "description": "tests.test_grippers.test_robotiq_85",
        "peekOfCode": "def robotiq_tester(render,\n                   total_iters=1,\n                   test_y=True):\n    gripper = Robotiq85Gripper()\n    tester = GripperTester(\n        gripper=gripper,\n        pos=\"-0.02 0 0.3\",\n        quat=\"0 0 1 0\",\n        gripper_low_pos=-0.065,\n        gripper_high_pos=0.01,",
        "detail": "tests.test_grippers.test_robotiq_85",
        "documentation": {}
    },
    {
        "label": "test_robotiq_three_finger",
        "kind": 2,
        "importPath": "tests.test_grippers.test_robotiq_threefinger",
        "description": "tests.test_grippers.test_robotiq_threefinger",
        "peekOfCode": "def test_robotiq_three_finger():\n    robotiq_three_finger_tester(False)\ndef robotiq_three_finger_tester(render,\n                                total_iters=1,\n                                test_y=True):\n    gripper = RobotiqThreeFingerGripper()\n    tester = GripperTester(\n        gripper=gripper,\n        pos=\"0 0 0.3\",\n        quat=\"0 0 1 0\",",
        "detail": "tests.test_grippers.test_robotiq_threefinger",
        "documentation": {}
    },
    {
        "label": "robotiq_three_finger_tester",
        "kind": 2,
        "importPath": "tests.test_grippers.test_robotiq_threefinger",
        "description": "tests.test_grippers.test_robotiq_threefinger",
        "peekOfCode": "def robotiq_three_finger_tester(render,\n                                total_iters=1,\n                                test_y=True):\n    gripper = RobotiqThreeFingerGripper()\n    tester = GripperTester(\n        gripper=gripper,\n        pos=\"0 0 0.3\",\n        quat=\"0 0 1 0\",\n        gripper_low_pos=-0.02,\n        gripper_high_pos=0.1,",
        "detail": "tests.test_grippers.test_robotiq_threefinger",
        "documentation": {}
    },
    {
        "label": "this_directory",
        "kind": 5,
        "importPath": "setup",
        "description": "setup",
        "peekOfCode": "this_directory = path.abspath(path.dirname(__file__))\nwith open(path.join(this_directory, 'README.md'), encoding='utf-8') as f:\n    lines = f.readlines()\n# remove images from README\nlines = [x for x in lines if '.png' not in x]\nlong_description = ''.join(lines)\nsetup(\n    name=\"robosuite\",\n    packages=[\n        package for package in find_packages() if package.startswith(\"robosuite\")",
        "detail": "setup",
        "documentation": {}
    },
    {
        "label": "lines",
        "kind": 5,
        "importPath": "setup",
        "description": "setup",
        "peekOfCode": "lines = [x for x in lines if '.png' not in x]\nlong_description = ''.join(lines)\nsetup(\n    name=\"robosuite\",\n    packages=[\n        package for package in find_packages() if package.startswith(\"robosuite\")\n    ],\n    install_requires=[\n        \"numpy>=1.13.3\",\n        \"numba>=0.49.1\",",
        "detail": "setup",
        "documentation": {}
    },
    {
        "label": "long_description",
        "kind": 5,
        "importPath": "setup",
        "description": "setup",
        "peekOfCode": "long_description = ''.join(lines)\nsetup(\n    name=\"robosuite\",\n    packages=[\n        package for package in find_packages() if package.startswith(\"robosuite\")\n    ],\n    install_requires=[\n        \"numpy>=1.13.3\",\n        \"numba>=0.49.1\",\n        \"scipy>=1.2.3\",",
        "detail": "setup",
        "documentation": {}
    }
]